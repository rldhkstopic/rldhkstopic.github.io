<!DOCTYPE html>
<html lang="ko">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>{% if page.title %}{{ page.title }} | {% endif %}{{ site.title }}</title>
    <meta name="description" content="{% if page.excerpt %}{{ page.excerpt | strip_html | strip_newlines | truncate: 160 }}{% else %}{{ site.description }}{% endif %}">
    
    <link rel="stylesheet" href="{{ '/assets/css/main.css' | relative_url }}">
    <link rel="canonical" href="{{ page.url | replace:'index.html','' | absolute_url }}">
    
    <!-- Google Analytics 4 (GA4) -->
    {% if site.google_analytics %}
    <script async src="https://www.googletagmanager.com/gtag/js?id={{ site.google_analytics }}"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', '{{ site.google_analytics }}');
    </script>
    {% endif %}
    
    <!-- Prism.js for syntax highlighting -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" id="prism-theme-light">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css" id="prism-theme-dark" media="(prefers-color-scheme: dark)">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.css">
    
    <!-- MathJax for LaTeX -->
    <script>
      window.MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          displayMath: [['$$', '$$'], ['\\[', '\\]']]
        }
      };
    </script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    
    {% comment %}{% seo %}{% endcomment %}
  </head>
  <body class="{% if page.url == '/' or page.url == '/index.html' %}home-page{% endif %}">
    <header class="site-header">
      <div class="wrapper">
        <a class="site-title" href="{{ '/' | relative_url }}">{{ site.title }}</a>
        <nav class="site-nav">
          <div class="trigger">
            {% for item in site.navigation %}
              <a class="page-link" href="{{ item.url | relative_url }}">{{ item.title }}</a>
            {% endfor %}
            <!-- RSS 피드 -->
            <a class="page-link" href="{{ '/feed.xml' | relative_url }}" aria-label="RSS 피드" title="RSS 피드">
              <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M4 4.5C8.5 4.5 12.5 8.5 12.5 13M4 4.5c0 0 0 0 0 0M4 4.5C3 4.5 2 5 2 5.5v13c0 .5.5 1 1 1h13c.5 0 1-.5 1-1 0-1 0-1 0-1"/>
                <circle cx="5" cy="19" r="1" fill="currentColor"/>
              </svg>
            </a>
            <!-- 검색 버튼 -->
            <button class="search-toggle" id="searchToggle" aria-label="검색">
              <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <circle cx="11" cy="11" r="8"></circle>
                <path d="m21 21-4.35-4.35"></path>
              </svg>
            </button>
            <!-- 라이트/다크 모드 토글 (Uiverse RiccardoRapelli jolly-chicken-91) -->
            <label class="switch theme-toggle" aria-label="테마 전환">
              <input id="themeToggleInput" type="checkbox" />
              <div class="slider round">
                <div class="sun-moon">
                  <svg id="moon-dot-1" class="moon-dot" viewBox="0 0 100 100">
                    <circle cx="50" cy="50" r="50"></circle>
                  </svg>
                  <svg id="moon-dot-2" class="moon-dot" viewBox="0 0 100 100">
                    <circle cx="50" cy="50" r="50"></circle>
                  </svg>
                  <svg id="moon-dot-3" class="moon-dot" viewBox="0 0 100 100">
                    <circle cx="50" cy="50" r="50"></circle>
                  </svg>
                  <svg id="light-ray-1" class="light-ray" viewBox="0 0 100 100">
                    <circle cx="50" cy="50" r="50"></circle>
                  </svg>
                  <svg id="light-ray-2" class="light-ray" viewBox="0 0 100 100">
                    <circle cx="50" cy="50" r="50"></circle>
                  </svg>
                  <svg id="light-ray-3" class="light-ray" viewBox="0 0 100 100">
                    <circle cx="50" cy="50" r="50"></circle>
                  </svg>
                  <svg id="cloud-1" class="cloud-dark" viewBox="0 0 100 100">
                    <circle cx="50" cy="50" r="50"></circle>
                  </svg>
                  <svg id="cloud-2" class="cloud-dark" viewBox="0 0 100 100">
                    <circle cx="50" cy="50" r="50"></circle>
                  </svg>
                  <svg id="cloud-3" class="cloud-dark" viewBox="0 0 100 100">
                    <circle cx="50" cy="50" r="50"></circle>
                  </svg>
                  <svg id="cloud-4" class="cloud-light" viewBox="0 0 100 100">
                    <circle cx="50" cy="50" r="50"></circle>
                  </svg>
                  <svg id="cloud-5" class="cloud-light" viewBox="0 0 100 100">
                    <circle cx="50" cy="50" r="50"></circle>
                  </svg>
                  <svg id="cloud-6" class="cloud-light" viewBox="0 0 100 100">
                    <circle cx="50" cy="50" r="50"></circle>
                  </svg>
                </div>
                <div class="stars">
                  <svg id="star-1" class="star" viewBox="0 0 20 20">
                    <path d="M 0 10 C 10 10,10 10 ,0 10 C 10 10 , 10 10 , 10 20 C 10 10 , 10 10 , 20 10 C 10 10 , 10 10 , 10 0 C 10 10,10 10 ,0 10 Z"></path>
                  </svg>
                  <svg id="star-2" class="star" viewBox="0 0 20 20">
                    <path d="M 0 10 C 10 10,10 10 ,0 10 C 10 10 , 10 10 , 10 20 C 10 10 , 10 10 , 20 10 C 10 10 , 10 10 , 10 0 C 10 10,10 10 ,0 10 Z"></path>
                  </svg>
                  <svg id="star-3" class="star" viewBox="0 0 20 20">
                    <path d="M 0 10 C 10 10,10 10 ,0 10 C 10 10 , 10 10 , 10 20 C 10 10 , 10 10 , 20 10 C 10 10 , 10 10 , 10 0 C 10 10,10 10 ,0 10 Z"></path>
                  </svg>
                  <svg id="star-4" class="star" viewBox="0 0 20 20">
                    <path d="M 0 10 C 10 10,10 10 ,0 10 C 10 10 , 10 10 , 10 20 C 10 10 , 10 10 , 20 10 C 10 10 , 10 10 , 10 0 C 10 10,10 10 ,0 10 Z"></path>
                  </svg>
                </div>
              </div>
            </label>
          </div>
        </nav>
      </div>
    </header>

    <!-- 검색 모달 -->
    <div class="search-modal" id="searchModal">
      <div class="search-modal-content">
        <div class="search-header">
          <input type="text" id="searchInput" class="search-input" placeholder="포스트 검색..." autocomplete="off">
          <button class="search-close" id="searchClose" aria-label="닫기">✕</button>
        </div>
        <div class="search-results" id="searchResults"></div>
      </div>
    </div>

    <main class="page-content">
      <div class="wrapper">
        {{ content }}
      </div>
    </main>

    {% unless page.url == '/' or page.url == '/index.html' %}
    <footer class="site-footer">
      <div class="wrapper">
        <p>&copy; {{ 'now' | date: "%Y" }} {{ site.author }}. All rights reserved.</p>
        <p>Powered by <a href="https://jekyllrb.com/">Jekyll</a> & <a href="https://pages.github.com/">GitHub Pages</a></p>
      </div>
    </footer>
    {% endunless %}
    
    <!-- Prism.js for syntax highlighting -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.js"></script>
    
    <script>
      // 메인 페이지인지 확인하여 body에 클래스 추가
      if (window.location.pathname === '/' || window.location.pathname === '/index.html') {
        document.documentElement.classList.add('home-page');
      }

      // 카테고리 토글 함수
      function toggleCategory(link) {
        const categoryItem = link.closest('.category-item');
        const isActive = categoryItem.classList.contains('active');
        
        // 다른 카테고리 닫기 (선택사항 - 원하면 주석 처리)
        // document.querySelectorAll('.category-item').forEach(item => {
        //   if (item !== categoryItem) {
        //     item.classList.remove('active');
        //   }
        // });
        
        // 현재 카테고리 토글 (CSS transform으로 처리되므로 JavaScript에서 텍스트 변경 불필요)
        if (isActive) {
          categoryItem.classList.remove('active');
        } else {
          categoryItem.classList.add('active');
        }
      }

      // 코드 블록 확장 기능 및 팝업 모달
      function processCodeBlocks() {
        const codeBlocks = document.querySelectorAll('.post-content pre');
        
        codeBlocks.forEach(pre => {
          pre.classList.add('line-numbers');
          pre.removeAttribute('tabindex');
          pre.style.outline = 'none';
          
          const code = pre.querySelector('code');
          if (!code) return;

          // 언어 추출 및 data-lang 표시
          const langMatch = code.className.match(/language-([\w-]+)/);
          const lang = langMatch ? langMatch[1] : 'code';
          pre.setAttribute('data-lang', lang);

          // 라인넘버 플러그인용 클래스는 pre에만 유지
          code.classList.remove('line-numbers');

          // 긴 코드일 때만 확장 가능 표시
          const lines = (code.textContent || code.innerText || '').split('\n');
          if (lines.length > 15) {
            pre.classList.add('code-expandable');
          } else {
            pre.classList.remove('code-expandable');
          }

          // 상단 우측 + 버튼 생성 (중복 방지)
          if (!pre.querySelector('.code-expand-btn')) {
            const btn = document.createElement('button');
            btn.className = 'code-expand-btn';
            btn.innerHTML = '+';
            btn.setAttribute('aria-label', '전체 코드 보기');
            btn.addEventListener('click', function(e) {
              e.stopPropagation();
              openCodeModal(pre, lang);
            });
            pre.appendChild(btn);
          }
        });
      }
      
      // 코드 팝업 모달 열기
      function openCodeModal(preElement, langOverride) {
        // 모달이 이미 있으면 제거
        const existingModal = document.getElementById('code-modal');
        if (existingModal) {
          existingModal.remove();
        }
        
        // 모달 생성
        const modal = document.createElement('div');
        modal.id = 'code-modal';
        modal.className = 'code-modal';
        
        const code = preElement.querySelector('code');
        const codeClone = code.cloneNode(true);
        
        // 언어 클래스 가져오기
        const language = code.className.match(/language-([\w-]+)/);
        const langClass = langOverride ? `language-${langOverride}` : (language ? language[0] : '');
        
        modal.innerHTML = `
          <div class="code-modal-content">
            <div class="code-modal-header">
              <h3 class="code-modal-title">전체 코드${langClass ? ' (' + langClass.replace('language-', '') + ')' : ''}</h3>
              <button class="code-modal-close">닫기</button>
            </div>
            <div class="code-modal-body">
              <pre class="highlight ${langClass}"><code class="${langClass}">${codeClone.innerHTML}</code></pre>
            </div>
          </div>
        `;
        
        document.body.appendChild(modal);
        
        // Prism.js로 하이라이팅 (있는 경우)
        if (window.Prism && window.Prism.highlightElement) {
          const modalCode = modal.querySelector('code');
          if (modalCode) {
            window.Prism.highlightElement(modalCode);
          }
        }
        
        // 애니메이션을 위해 약간의 지연 후 active 클래스 추가
        setTimeout(() => {
          modal.classList.add('active');
        }, 10);
        
        // 닫기 버튼 이벤트
        const closeBtn = modal.querySelector('.code-modal-close');
        closeBtn.addEventListener('click', () => {
          closeCodeModal(modal);
        });
        
        // 배경 클릭 시 닫기
        modal.addEventListener('click', (e) => {
          if (e.target === modal) {
            closeCodeModal(modal);
          }
        });
        
        // ESC 키로 닫기
        const escHandler = function(e) {
          if (e.key === 'Escape') {
            closeCodeModal(modal);
            document.removeEventListener('keydown', escHandler);
          }
        };
        document.addEventListener('keydown', escHandler);
      }
      
      
      // 코드 팝업 모달 닫기
      function closeCodeModal(modal) {
        modal.classList.remove('active');
        setTimeout(() => {
          modal.remove();
        }, 300);
      }
      
      // DOMContentLoaded와 Prism.js 로드 후 실행
      document.addEventListener('DOMContentLoaded', function() {
        processCodeBlocks();
        
        // Prism.js가 로드된 후에도 실행
        if (window.Prism) {
          setTimeout(processCodeBlocks, 100);
        }
      });
      
      // Prism.js autoloader가 완료된 후 실행
      if (window.Prism && window.Prism.plugins && window.Prism.plugins.autoloader) {
        window.Prism.plugins.autoloader.onload = function() {
          setTimeout(processCodeBlocks, 100);
        };
      }
      
      // 테마 전환 기능
      (function() {
        const themeInput = document.getElementById('themeToggleInput');
        const html = document.documentElement;
        const prismLight = document.getElementById('prism-theme-light');
        const prismDark = document.getElementById('prism-theme-dark');
        
        // 저장된 테마 불러오기
        const savedTheme = localStorage.getItem('theme') || 'light';
        html.setAttribute('data-theme', savedTheme);
        if (themeInput) {
          themeInput.checked = savedTheme === 'dark';
        }
        updatePrismTheme(savedTheme);
        
        // 테마 전환 안개 효과
        function addThemeFog() {
          document.documentElement.classList.add('theme-fade');
          setTimeout(() => {
            document.documentElement.classList.remove('theme-fade');
          }, 500);
        }
        
        // Prism 테마 업데이트 함수
        function updatePrismTheme(theme) {
          if (prismLight && prismDark) {
            if (theme === 'dark') {
              prismLight.disabled = true;
              prismDark.disabled = false;
            } else {
              prismLight.disabled = false;
              prismDark.disabled = true;
            }
          }
        }
        
        // 토글 change 이벤트
        if (themeInput) {
          themeInput.addEventListener('change', function() {
            const newTheme = themeInput.checked ? 'dark' : 'light';
            html.setAttribute('data-theme', newTheme);
            localStorage.setItem('theme', newTheme);
            updatePrismTheme(newTheme);
            addThemeFog();
            
            // Prism.js 재하이라이팅
            if (window.Prism) {
              document.querySelectorAll('pre code').forEach(function(block) {
                Prism.highlightElement(block);
              });
            }
          });
        }

        // 초기 로드 시도에도 부드러운 전환 효과 (테마 복원 시)
        addThemeFog();
      })();
      
      // GA4 방문자 통계 데이터 로드
      (function() {
        const totalEl = document.getElementById('total-visitors');
        const todayEl = document.getElementById('today-visitors');
        const yesterdayEl = document.getElementById('yesterday-visitors');
        
        if (!totalEl || !todayEl || !yesterdayEl) {
          console.log('방문자 통계 요소를 찾을 수 없습니다.');
          return;
        }
        
        // 여러 경로 시도 (assets 폴더가 가장 안정적)
        const possiblePaths = [
          '{{ "/assets/analytics.json" | relative_url }}',
          '/assets/analytics.json',
          '{{ site.baseurl }}/assets/analytics.json',
          '{{ "/_data/analytics.json" | relative_url }}'
        ];
        
        let fetchAttempted = false;
        
        function tryFetch(path) {
          if (fetchAttempted) return;
          fetchAttempted = true;
          
          fetch(path)
            .then(response => {
              if (!response.ok) {
                throw new Error(`HTTP ${response.status}: ${response.statusText}`);
              }
              return response.json();
            })
            .then(data => {
              console.log('Analytics 데이터 로드 성공:', data);
              if (data.total !== undefined && data.total !== null) {
                totalEl.textContent = data.total.toLocaleString();
              }
              if (data.today !== undefined && data.today !== null) {
                todayEl.textContent = data.today.toLocaleString();
              }
              if (data.yesterday !== undefined && data.yesterday !== null) {
                yesterdayEl.textContent = data.yesterday.toLocaleString();
              }
            })
            .catch(error => {
              console.log('Analytics 데이터 로드 실패:', path, error);
              // 다른 경로 시도
              const nextPath = possiblePaths.find(p => p !== path);
              if (nextPath && possiblePaths.indexOf(path) < possiblePaths.length - 1) {
                fetchAttempted = false;
                setTimeout(() => tryFetch(nextPath), 100);
              }
            });
        }
        
        // 첫 번째 경로로 시도
        tryFetch(possiblePaths[0]);
      })();

      // 좋아요 기능
      function toggleLike() {
        const btn = document.querySelector('.post-like-btn');
        const countEl = document.getElementById('like-count');
        if (!btn || !countEl) return;

        const postUrl = window.location.pathname;
        const storageKey = `like_${postUrl}`;
        const isLiked = localStorage.getItem(storageKey) === 'true';
        let currentCount = parseInt(countEl.textContent) || 0;

        if (isLiked) {
          // 좋아요 취소
          btn.classList.remove('liked');
          currentCount = Math.max(0, currentCount - 1);
          localStorage.removeItem(storageKey);
        } else {
          // 좋아요 추가
          btn.classList.add('liked');
          currentCount += 1;
          localStorage.setItem(storageKey, 'true');
        }

        countEl.textContent = currentCount;
      }

      // 페이지 로드 시 좋아요 상태 복원
      document.addEventListener('DOMContentLoaded', function() {
        const btn = document.querySelector('.post-like-btn');
        const countEl = document.getElementById('like-count');
        if (btn && countEl) {
          const postUrl = window.location.pathname;
          const storageKey = `like_${postUrl}`;
          const isLiked = localStorage.getItem(storageKey) === 'true';
          
          if (isLiked) {
            btn.classList.add('liked');
            const currentCount = parseInt(countEl.textContent) || 0;
            if (currentCount === 0) {
              countEl.textContent = '1';
            }
          }
        }

        // 본문에서 각주(footnotes) 또는 "참고 자료" 섹션 추출하여 하단 컨테이너로 이동
        const postContent = document.getElementById('post-content');
        if (!postContent) return;

        const referencesList = [];
        
        // 방법 1: 각주(footnotes) 섹션 찾기 (Jekyll/Kramdown이 렌더링한 형태)
        const footnotesSection = postContent.querySelector('section.footnotes, div.footnotes, ol.footnotes');
        if (footnotesSection) {
          const footnoteItems = footnotesSection.querySelectorAll('li[id^="fn"], li[class*="footnote"]');
          footnoteItems.forEach(item => {
            const link = item.querySelector('a[href^="#"]');
            const text = item.textContent.trim();
            // 각주 내용에서 링크 추출
            const contentLinks = item.querySelectorAll('a[href^="http"]');
            if (contentLinks.length > 0) {
              contentLinks.forEach(link => {
                referencesList.push({
                  title: link.textContent.trim() || text.split(' - ')[0] || text,
                  url: link.href
                });
              });
            } else if (text) {
              // 링크가 없어도 텍스트만이라도 추가
              const match = text.match(/\[([^\]]+)\]\((https?:\/\/[^\)]+)\)/);
              if (match) {
                referencesList.push({
                  title: match[1],
                  url: match[2]
                });
              }
            }
          });
        }

        // 방법 2: "참고 자료" 또는 "레퍼런스" 제목 찾기
        const allHeadings = postContent.querySelectorAll('h2, h3');
        let referencesHeading = null;
        
        for (let heading of allHeadings) {
          const text = heading.textContent.trim();
          if (text === '참고 자료' || text === '레퍼런스' || text === 'References' || heading.id === '참고-자료' || heading.id === '레퍼런스' || heading.id === 'references') {
            referencesHeading = heading;
            break;
          }
        }

        if (referencesHeading) {
          let current = referencesHeading.nextElementSibling;

          // 다음 h2, h3, h1 또는 article 끝까지 수집
          while (current) {
            const tagName = current.tagName;
            
            // 다음 주요 제목을 만나면 중단
            if (tagName === 'H2' || tagName === 'H3' || tagName === 'H1') {
              break;
            }

            // 리스트에서 링크 추출
            if (tagName === 'UL' || tagName === 'OL') {
              const links = current.querySelectorAll('a[href^="http"]');
              links.forEach(link => {
                referencesList.push({
                  title: link.textContent.trim(),
                  url: link.href
                });
              });
            } 
            // 단락에서 링크 추출
            else if (tagName === 'P') {
              const links = current.querySelectorAll('a[href^="http"]');
              links.forEach(link => {
                referencesList.push({
                  title: link.textContent.trim(),
                  url: link.href
                });
              });
            }
            // 각주 형식 파싱: [^1]: [제목](URL) 형식
            else if (tagName === 'P' || tagName === 'DIV') {
              const text = current.textContent.trim();
              // [^1]: [제목](URL) - 설명 형식 매칭
              const footnoteRegex = /\[\^\d+\]:\s*\[([^\]]+)\]\((https?:\/\/[^\)]+)\)/g;
              let match;
              while ((match = footnoteRegex.exec(text)) !== null) {
                referencesList.push({
                  title: match[1],
                  url: match[2]
                });
              }
            }

            current = current.nextElementSibling;
          }

          // 참고 자료 섹션 제거
          let toRemove = referencesHeading;
          const stopAt = current; // 다음 제목 또는 null
          
          while (toRemove && toRemove !== stopAt) {
            const next = toRemove.nextElementSibling;
            toRemove.remove();
            toRemove = next;
          }
        }

        // 방법 3: 본문 전체에서 각주 링크 찾기 (마크다운 각주 형식)
        if (referencesList.length === 0) {
          // 각주 정의 찾기: [^1]: 형식
          const allParagraphs = postContent.querySelectorAll('p');
          allParagraphs.forEach(p => {
            const text = p.textContent.trim();
            // [^1]: [제목](URL) - 설명 형식
            const footnoteRegex = /\[\^\d+\]:\s*\[([^\]]+)\]\((https?:\/\/[^\)]+)\)/g;
            let match;
            while ((match = footnoteRegex.exec(text)) !== null) {
              referencesList.push({
                title: match[1],
                url: match[2]
              });
            }
          });
        }

        // 하단 컨테이너에 참고 자료 추가
        if (referencesList.length > 0) {
          const footerInfo = document.querySelector('.post-footer-info');
          if (footerInfo) {
            // 이미 참고 자료 섹션이 있는지 확인
            let existingRefSection = footerInfo.querySelector('.post-references-section');
            
            if (!existingRefSection) {
              const referencesSection = document.createElement('div');
              referencesSection.className = 'post-references-section';
              
              // 제목만 링크로 표시
              const formatIEEEReference = (ref, index) => {
                return `
                  <li class="post-reference-item">
                    <a href="${ref.url}" target="_blank" rel="noopener noreferrer" class="post-reference-link">
                      ${ref.title}
                    </a>
                  </li>
                `;
              };
              
              const referencesHTML = referencesList.map((ref, index) => formatIEEEReference(ref, index)).join('');
              
              referencesSection.innerHTML = `
                <h3 class="post-footer-title">레퍼런스</h3>
                <ol class="post-references">
                  ${referencesHTML}
                </ol>
              `;
              
              // post-actions 다음에 삽입 (태그 섹션 다음, 참고 자료 섹션 앞)
              const actionsSection = footerInfo.querySelector('.post-actions');
              if (actionsSection) {
                actionsSection.insertAdjacentElement('afterend', referencesSection);
              } else {
                const tagsSection = footerInfo.querySelector('.post-tags-section');
                if (tagsSection) {
                  tagsSection.insertAdjacentElement('afterend', referencesSection);
                } else {
                  footerInfo.appendChild(referencesSection);
                }
              }
            } else {
              // 기존 섹션이 있으면 링크만 추가
              const existingList = existingRefSection.querySelector('.post-references');
              if (existingList) {
                const formatIEEEReference = (ref, index) => {
                  return `
                    <li class="post-reference-item">
                      <a href="${ref.url}" target="_blank" rel="noopener noreferrer" class="post-reference-link">
                        ${ref.title}
                      </a>
                    </li>
                  `;
                };
                
                referencesList.forEach((ref, index) => {
                  const li = document.createElement('li');
                  li.className = 'post-reference-item';
                  const currentCount = existingList.querySelectorAll('.post-reference-item').length;
                  li.innerHTML = formatIEEEReference(ref, currentCount).trim();
                  existingList.appendChild(li);
                });
              }
            }
          }
        }
      });

      // 검색 기능
      (function() {
        const searchToggle = document.getElementById('searchToggle');
        const searchModal = document.getElementById('searchModal');
        const searchClose = document.getElementById('searchClose');
        const searchInput = document.getElementById('searchInput');
        const searchResults = document.getElementById('searchResults');
        
        // 포스트 데이터 로드
        let postsData = [];
        
        function loadPostsData() {
          {% for post in site.posts %}
          postsData.push({
            title: {{ post.title | jsonify }},
            url: {{ post.url | relative_url | jsonify }},
            excerpt: {{ post.excerpt | strip_html | truncatewords: 50 | jsonify }},
            date: {{ post.date | date: "%Y년 %m월 %d일" | jsonify }},
            category: {{ post.category | jsonify }},
            tags: {{ post.tags | jsonify }}
          });
          {% endfor %}
        }
        
        function searchPosts(query) {
          if (!query.trim()) {
            searchResults.innerHTML = '';
            return;
          }
          
          const lowerQuery = query.toLowerCase();
          const results = postsData.filter(post => {
            const titleMatch = post.title.toLowerCase().includes(lowerQuery);
            const excerptMatch = post.excerpt.toLowerCase().includes(lowerQuery);
            const tagMatch = post.tags.some(tag => tag.toLowerCase().includes(lowerQuery));
            return titleMatch || excerptMatch || tagMatch;
          });
          
          if (results.length === 0) {
            searchResults.innerHTML = '<div class="search-no-results">검색 결과가 없습니다.</div>';
            return;
          }
          
          searchResults.innerHTML = results.map(post => `
            <div class="search-result-item" onclick="window.location.href='${post.url}'">
              <div class="search-result-title">${post.title}</div>
              <div class="search-result-excerpt">${post.excerpt}</div>
              <div class="search-result-meta">${post.date} • ${post.category || '기타'}</div>
            </div>
          `).join('');
        }
        
        searchToggle?.addEventListener('click', () => {
          searchModal.classList.add('active');
          setTimeout(() => searchInput.focus(), 100);
          loadPostsData();
        });
        
        searchClose?.addEventListener('click', () => {
          searchModal.classList.remove('active');
          searchInput.value = '';
          searchResults.innerHTML = '';
        });
        
        searchInput?.addEventListener('input', (e) => {
          searchPosts(e.target.value);
        });
        
        searchModal?.addEventListener('click', (e) => {
          if (e.target === searchModal) {
            searchModal.classList.remove('active');
            searchInput.value = '';
            searchResults.innerHTML = '';
          }
        });
        
        document.addEventListener('keydown', (e) => {
          if ((e.ctrlKey || e.metaKey) && e.key === 'k') {
            e.preventDefault();
            searchModal.classList.add('active');
            setTimeout(() => searchInput.focus(), 100);
            loadPostsData();
          }
          if (e.key === 'Escape' && searchModal.classList.contains('active')) {
            searchModal.classList.remove('active');
            searchInput.value = '';
            searchResults.innerHTML = '';
          }
        });
      })();

      // 목차(TOC) 생성 및 스크롤 하이라이트
      (function() {
        const postTOC = document.getElementById('postTOC');
        const postContent = document.getElementById('post-content');
        const tocList = document.getElementById('tocList');
          
        if (postContent && tocList) {
          // 모든 헤더 찾기 (h1~h6)
          const allHeadings = postContent.querySelectorAll('h1, h2, h3, h4, h5, h6');
          
          // "참고 자료", "레퍼런스", "References" 제외
          const filteredHeadings = Array.from(allHeadings).filter(heading => {
            const text = heading.textContent.trim();
            return !text.includes('참고 자료') && 
                   !text.includes('레퍼런스') && 
                   !text.includes('References') &&
                   !text.includes('참고자료');
          });
          
          // 가장 높은 헤더 수준 찾기
          let minLevel = 6; // 최대값으로 시작
          filteredHeadings.forEach(heading => {
            const level = parseInt(heading.tagName.charAt(1));
            if (level < minLevel) {
              minLevel = level;
            }
          });
          
          // 가장 높은 헤더 수준만 필터링
          const headings = filteredHeadings.filter(heading => {
            const level = parseInt(heading.tagName.charAt(1));
            return level === minLevel;
          });
          
          function createTOCItem(heading, index, targetList) {
            const id = `heading-${index}`;
            // ID는 한 번만 설정
            if (!heading.id) {
              heading.id = id;
            }
            
            const level = parseInt(heading.tagName.charAt(1));
            const li = document.createElement('li');
            li.className = `toc-level-${level}`;
            
            const a = document.createElement('a');
            a.href = `#${id}`;
            a.textContent = heading.textContent;
            a.addEventListener('click', (e) => {
              e.preventDefault();
              const header = document.querySelector('.post-header');
              const headerHeight = header ? header.offsetHeight + 20 : 100;
              const elementPosition = heading.getBoundingClientRect().top + window.pageYOffset;
              const offsetPosition = elementPosition - headerHeight;
              
              window.scrollTo({
                top: offsetPosition,
                behavior: 'smooth'
              });
              window.history.pushState(null, '', `#${id}`);
            });
            
            li.appendChild(a);
            targetList.appendChild(li);
          }
          
          if (headings.length > 0) {
            headings.forEach((heading, index) => {
              if (tocList) {
                createTOCItem(heading, index, tocList);
              }
            });
            
            // 스크롤 하이라이트
            const header = document.querySelector('.post-header');
            const headerHeight = header ? header.offsetHeight + 20 : 100;
            
            function updateActiveHeading() {
              if (headings.length === 0) return;
              
              const scrollPosition = window.scrollY + headerHeight + 100;
              let activeHeading = headings[0];
              
              // 현재 스크롤 위치보다 위에 있는 가장 가까운 제목 찾기
              for (let i = headings.length - 1; i >= 0; i--) {
                const heading = headings[i];
                const rect = heading.getBoundingClientRect();
                const headingTop = rect.top + window.scrollY;
                
                if (headingTop <= scrollPosition) {
                  activeHeading = heading;
                  break;
                }
              }
              
              if (tocList && activeHeading) {
                const id = activeHeading.id;
                tocList.querySelectorAll('a').forEach(link => {
                  link.classList.remove('active');
                  if (link.getAttribute('href') === `#${id}`) {
                    link.classList.add('active');
                  }
                });
              }
            }
            
            // 초기 상태 업데이트
            setTimeout(updateActiveHeading, 200);
            
            // 스크롤 이벤트로 활성 상태 업데이트
            let ticking = false;
            const handleScroll = () => {
              if (!ticking) {
                window.requestAnimationFrame(() => {
                  updateActiveHeading();
                  ticking = false;
                });
                ticking = true;
              }
            };
            
            window.addEventListener('scroll', handleScroll, { passive: true });
            
            // IntersectionObserver로 더 정확한 감지
            const observerOptions = {
              root: null,
              rootMargin: `-${headerHeight + 100}px 0px -50% 0px`,
              threshold: [0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1]
            };
            
            const observer = new IntersectionObserver((entries) => {
              // 가장 많이 보이는 제목 찾기
              let maxVisible = 0;
              let mostVisibleHeading = null;
              
              entries.forEach(entry => {
                if (entry.isIntersecting && entry.intersectionRatio > maxVisible) {
                  maxVisible = entry.intersectionRatio;
                  mostVisibleHeading = entry.target;
                }
              });
              
              if (mostVisibleHeading && tocList) {
                const id = mostVisibleHeading.id;
                tocList.querySelectorAll('a').forEach(link => {
                  link.classList.remove('active');
                  if (link.getAttribute('href') === `#${id}`) {
                    link.classList.add('active');
                  }
                });
              } else {
                // IntersectionObserver로 감지되지 않으면 스크롤 위치 기반으로 업데이트
                updateActiveHeading();
              }
            }, observerOptions);
            
            headings.forEach(heading => observer.observe(heading));
          } else {
            if (postTOC) postTOC.style.display = 'none';
          }
        }
      })();

      // 공유 기능
      function shareToTwitter() {
        const url = encodeURIComponent(window.location.href);
        const title = encodeURIComponent(document.title);
        window.open(`https://twitter.com/intent/tweet?url=${url}&text=${title}`, '_blank', 'width=550,height=420');
      }

      function shareToFacebook() {
        const url = encodeURIComponent(window.location.href);
        window.open(`https://www.facebook.com/sharer/sharer.php?u=${url}`, '_blank', 'width=550,height=420');
      }

      function copyLink() {
        const url = window.location.href;
        navigator.clipboard.writeText(url).then(() => {
          const btn = event.target.closest('.share-btn');
          const originalHTML = btn.innerHTML;
          btn.innerHTML = '<svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M20 6L9 17l-5-5"/></svg>';
          btn.style.color = 'var(--accent-color)';
          setTimeout(() => {
            btn.innerHTML = originalHTML;
            btn.style.color = '';
          }, 2000);
        });
      }
      
    </script>
  </body>
</html>

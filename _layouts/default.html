<!DOCTYPE html>
<html lang="ko">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>{% if page.title %}{{ page.title }} | {% endif %}{{ site.title }}</title>
    <meta name="description" content="{% if page.excerpt %}{{ page.excerpt | strip_html | strip_newlines | truncate: 160 }}{% else %}{{ site.description }}{% endif %}">
    
    <link rel="stylesheet" href="{{ '/assets/css/main.css' | relative_url }}">
    <!-- Bootstrap Icons for reference markers -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.3/font/bootstrap-icons.css">
    <link rel="canonical" href="{{ page.url | replace:'index.html','' | absolute_url }}">
    
    <!-- Google Analytics 4 (GA4) -->
    {% if site.google_analytics %}
    <script async src="https://www.googletagmanager.com/gtag/js?id={{ site.google_analytics }}"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', '{{ site.google_analytics }}');
    </script>
    {% endif %}
    
    <!-- Prism.js for syntax highlighting -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" id="prism-theme-light">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css" id="prism-theme-dark" media="(prefers-color-scheme: dark)">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.css">
    
    <!-- MathJax for LaTeX -->
    <script>
      window.MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          displayMath: [['$$', '$$'], ['\\[', '\\]']]
        }
      };
    </script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    
    {% comment %}{% seo %}{% endcomment %}
    
    <!-- Jekyll 설정을 JavaScript에 주입 (OAuth용) -->
    <script>
      /* jshint ignore:start */
      /* eslint-disable */
      // Jekyll Liquid 문법 사용 - IDE 경고는 무시해도 됨 (빌드 시 정상 작동)
      window.ADMIN_CONFIG_OVERRIDE = {
        adminPassword: {% if site.admin.admin_password %}"{{ site.admin.admin_password | escape }}"{% else %}null{% endif %},
        githubOAuth: {
          clientId: {% if site.admin.github_oauth.client_id %}"{{ site.admin.github_oauth.client_id | escape }}"{% else %}null{% endif %}
        }
      };
      /* eslint-enable */
      /* jshint ignore:end */
    </script>
    
    <!-- OAuth 스크립트 (관리자 페이지에서만 필요하지만 전역에서 사용 가능하도록) -->
    <script src="{{ '/assets/js/oauth.js' | relative_url }}"></script>
    <script src="{{ '/assets/js/admin.js' | relative_url }}"></script>
    
    <!-- 전역 로그인 클릭 핸들러 (인라인 onclick에서 사용) -->
    <script>
      // 전역 로그인 클릭 핸들러 (인라인 onclick에서 사용)
      function handleLoginClick(e) {
        e.preventDefault();
        e.stopPropagation();
        console.log('Login button clicked via inline handler');
        
        const loginPopup = document.getElementById('github-login-popup');
        if (!loginPopup) {
          console.error('Login popup not found!');
          return;
        }
        
        // 이미 열려있으면 닫기
        if (loginPopup.classList.contains('show')) {
          closeLoginPopup();
          return;
        }
        
        // 이미 로그인된 경우 로그아웃 팝업 표시
        if (window.authManager && window.authManager.isAuthenticated()) {
          const notAuthDiv = document.getElementById('login-popup-not-authenticated');
          const authDiv = document.getElementById('login-popup-authenticated');
          if (notAuthDiv) notAuthDiv.style.display = 'none';
          if (authDiv) authDiv.style.display = 'block';
        } else {
          // 로그인되지 않은 경우 로그인 팝업 표시
          const notAuthDiv = document.getElementById('login-popup-not-authenticated');
          const authDiv = document.getElementById('login-popup-authenticated');
          if (notAuthDiv) notAuthDiv.style.display = 'block';
          if (authDiv) authDiv.style.display = 'none';
        }
        
        // 애니메이션과 함께 표시
        loginPopup.style.display = 'block';
        setTimeout(() => {
          loginPopup.classList.add('show');
        }, 10);
        console.log('Popup should be visible now');
      }
      
      // 로그아웃 핸들러
      function handleLogout() {
        if (window.authManager) {
          window.authManager.clearToken();
          if (typeof window.updateAuthButtons === 'function') {
            window.updateAuthButtons();
          }
          closeLoginPopup();
          window.location.reload();
        }
      }
      
      // 팝업 닫기
      function closeLoginPopup() {
        const loginPopup = document.getElementById('github-login-popup');
        if (loginPopup) {
          loginPopup.classList.remove('show');
          setTimeout(() => {
            loginPopup.style.display = 'none';
          }, 200);
        }
      }
      
      // 모달 내 GitHub OAuth 버튼 클릭 핸들러
      function handleModalGitHubOAuth(e) {
        e.preventDefault();
        e.stopPropagation();
        console.log('Modal GitHub OAuth button clicked');
        
        // oauth.js가 로드되었는지 확인
        if (typeof window.startGitHubOAuth === 'function') {
          console.log('Calling startGitHubOAuth');
          window.startGitHubOAuth();
        } else {
          console.error('startGitHubOAuth function not found, redirecting to admin page');
          window.location.href = '/admin/';
        }
      }
    </script>
  </head>
  <body class="{% if page.url == '/' or page.url == '/index.html' %}home-page{% endif %}">
    <header class="site-header">
      <div class="wrapper">
        <a class="site-title" href="{{ '/' | relative_url }}">{{ site.title }}</a>
        <nav class="site-nav">
          <div class="trigger" style="position: relative;">
            <!-- 로그인 버튼 -->
            <button type="button" class="login-btn" id="login-btn" title="로그인" aria-label="로그인" onclick="handleLoginClick(event)">
              <svg class="github-icon" width="16" height="16" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg">
                <path d="M12 0c-6.626 0-12 5.373-12 12 0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z"/>
              </svg>
              <span class="login-btn-text">로그인</span>
            </button>
            <!-- 로그인 말풍선 (버튼 아래 표시) -->
            <div id="github-login-popup" class="login-popup" style="display: none;">
              <div class="login-popup-content">
                <button class="login-popup-close" id="close-login-popup" aria-label="닫기" onclick="closeLoginPopup()">
                  <i class="bi bi-x-lg"></i>
                </button>
                <div class="login-popup-body">
                  <!-- 로그인되지 않은 경우 -->
                  <div id="login-popup-not-authenticated">
                    {% if site.admin.github_oauth.client_id != "" %}
                    <button type="button" id="popup-github-oauth-btn" class="btn-github-oauth" onclick="handleModalGitHubOAuth(event)">
                      <svg class="github-logo" width="20" height="20" viewBox="0 0 24 24" fill="white" xmlns="http://www.w3.org/2000/svg">
                        <path d="M12 0c-6.626 0-12 5.373-12 12 0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z"/>
                      </svg>
                      <span>GitHub로 로그인하기</span>
                    </button>
                    {% else %}
                    <p style="text-align: center; color: var(--text-secondary); margin: 0;">
                      GitHub OAuth가 설정되지 않았습니다.
                    </p>
                    {% endif %}
                  </div>
                  
                  <!-- 로그인된 경우 -->
                  <div id="login-popup-authenticated" style="display: none;">
                    <button type="button" class="btn-logout" onclick="handleLogout()">
                      <span>로그아웃하기</span>
                    </button>
                  </div>
                </div>
              </div>
            </div>
            <!-- 상단 네비게이션 텍스트 링크 제거, 사이트 타이틀만 홈으로 사용 -->
            <!-- 라이트/다크 모드 토글 (Uiverse RiccardoRapelli jolly-chicken-91) -->
            <label class="switch theme-toggle" aria-label="테마 전환">
              <input id="themeToggleInput" type="checkbox" />
              <div class="slider round">
                <div class="sun-moon">
                  <svg id="moon-dot-1" class="moon-dot" viewBox="0 0 100 100">
                    <circle cx="50" cy="50" r="50"></circle>
                  </svg>
                  <svg id="moon-dot-2" class="moon-dot" viewBox="0 0 100 100">
                    <circle cx="50" cy="50" r="50"></circle>
                  </svg>
                  <svg id="moon-dot-3" class="moon-dot" viewBox="0 0 100 100">
                    <circle cx="50" cy="50" r="50"></circle>
                  </svg>
                  <svg id="light-ray-1" class="light-ray" viewBox="0 0 100 100">
                    <circle cx="50" cy="50" r="50"></circle>
                  </svg>
                  <svg id="light-ray-2" class="light-ray" viewBox="0 0 100 100">
                    <circle cx="50" cy="50" r="50"></circle>
                  </svg>
                  <svg id="light-ray-3" class="light-ray" viewBox="0 0 100 100">
                    <circle cx="50" cy="50" r="50"></circle>
                  </svg>
                  <svg id="cloud-1" class="cloud-dark" viewBox="0 0 100 100">
                    <circle cx="50" cy="50" r="50"></circle>
                  </svg>
                  <svg id="cloud-2" class="cloud-dark" viewBox="0 0 100 100">
                    <circle cx="50" cy="50" r="50"></circle>
                  </svg>
                  <svg id="cloud-3" class="cloud-dark" viewBox="0 0 100 100">
                    <circle cx="50" cy="50" r="50"></circle>
                  </svg>
                  <svg id="cloud-4" class="cloud-light" viewBox="0 0 100 100">
                    <circle cx="50" cy="50" r="50"></circle>
                  </svg>
                  <svg id="cloud-5" class="cloud-light" viewBox="0 0 100 100">
                    <circle cx="50" cy="50" r="50"></circle>
                  </svg>
                  <svg id="cloud-6" class="cloud-light" viewBox="0 0 100 100">
                    <circle cx="50" cy="50" r="50"></circle>
                  </svg>
                </div>
                <div class="stars">
                  <svg id="star-1" class="star" viewBox="0 0 20 20">
                    <path d="M 0 10 C 10 10,10 10 ,0 10 C 10 10 , 10 10 , 10 20 C 10 10 , 10 10 , 20 10 C 10 10 , 10 10 , 10 0 C 10 10,10 10 ,0 10 Z"></path>
                  </svg>
                  <svg id="star-2" class="star" viewBox="0 0 20 20">
                    <path d="M 0 10 C 10 10,10 10 ,0 10 C 10 10 , 10 10 , 10 20 C 10 10 , 10 10 , 20 10 C 10 10 , 10 10 , 10 0 C 10 10,10 10 ,0 10 Z"></path>
                  </svg>
                  <svg id="star-3" class="star" viewBox="0 0 20 20">
                    <path d="M 0 10 C 10 10,10 10 ,0 10 C 10 10 , 10 10 , 10 20 C 10 10 , 10 10 , 20 10 C 10 10 , 10 10 , 10 0 C 10 10,10 10 ,0 10 Z"></path>
                  </svg>
                  <svg id="star-4" class="star" viewBox="0 0 20 20">
                    <path d="M 0 10 C 10 10,10 10 ,0 10 C 10 10 , 10 10 , 10 20 C 10 10 , 10 10 , 20 10 C 10 10 , 10 10 , 10 0 C 10 10,10 10 ,0 10 Z"></path>
                  </svg>
                </div>
              </div>
            </label>
          </div>
        </nav>
      </div>
    </header>

    <main class="page-content">
      <div class="wrapper">
        {{ content }}
      </div>
    </main>

    {% unless page.url == '/' or page.url == '/index.html' %}
    <footer class="site-footer">
      <div class="wrapper">
        <p>&copy; {{ 'now' | date: "%Y" }} {{ site.author }}. All rights reserved.</p>
      </div>
    </footer>
    {% endunless %}
    
    <!-- Prism.js for syntax highlighting -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.js"></script>
    
    <script>
      // 메인 페이지인지 확인하여 body에 클래스 추가
      if (window.location.pathname === '/' || window.location.pathname === '/index.html') {
        document.documentElement.classList.add('home-page');
      }

      // 카테고리 토글 함수
      function toggleCategory(link) {
        const categoryItem = link.closest('.category-item');
        const isActive = categoryItem.classList.contains('active');
        
        // 다른 카테고리 닫기 (선택사항 - 원하면 주석 처리)
        // document.querySelectorAll('.category-item').forEach(item => {
        //   if (item !== categoryItem) {
        //     item.classList.remove('active');
        //   }
        // });
        
        // 현재 카테고리 토글 (CSS transform으로 처리되므로 JavaScript에서 텍스트 변경 불필요)
        if (isActive) {
          categoryItem.classList.remove('active');
        } else {
          categoryItem.classList.add('active');
        }
      }

      // 코드 블록 확장 기능 및 팝업 모달
      function processCodeBlocks() {
        const codeBlocks = document.querySelectorAll('.post-content pre');
        
        codeBlocks.forEach(pre => {
          pre.classList.add('line-numbers');
          pre.removeAttribute('tabindex');
          pre.style.outline = 'none';
          
          const code = pre.querySelector('code');
          if (!code) return;

          // 언어 추출 및 data-lang 표시
          const langMatch = code.className.match(/language-([\w-]+)/);
          const lang = langMatch ? langMatch[1] : 'code';
          pre.setAttribute('data-lang', lang);

          // 라인넘버 플러그인용 클래스는 pre에만 유지
          code.classList.remove('line-numbers');

          // 긴 코드일 때만 확장 가능 표시
          const lines = (code.textContent || code.innerText || '').split('\n');
          if (lines.length > 15) {
            pre.classList.add('code-expandable');
          } else {
            pre.classList.remove('code-expandable');
          }

          // 상단 우측 + 버튼 생성 (중복 방지)
          if (!pre.querySelector('.code-expand-btn')) {
            const btn = document.createElement('button');
            btn.className = 'code-expand-btn';
            btn.innerHTML = '+';
            btn.setAttribute('aria-label', '전체 코드 보기');
            btn.addEventListener('click', function(e) {
              e.stopPropagation();
              openCodeModal(pre, lang);
            });
            pre.appendChild(btn);
          }
        });
      }
      
      // 코드 팝업 모달 열기
      function openCodeModal(preElement, langOverride) {
        // 모달이 이미 있으면 제거
        const existingModal = document.getElementById('code-modal');
        if (existingModal) {
          existingModal.remove();
        }
        
        // 모달 생성
        const modal = document.createElement('div');
        modal.id = 'code-modal';
        modal.className = 'code-modal';
        
        const code = preElement.querySelector('code');
        const codeClone = code.cloneNode(true);
        
        // 언어 클래스 가져오기
        const language = code.className.match(/language-([\w-]+)/);
        const langClass = langOverride ? `language-${langOverride}` : (language ? language[0] : '');
        
        modal.innerHTML = `
          <div class="code-modal-content">
            <div class="code-modal-header">
              <h3 class="code-modal-title">전체 코드${langClass ? ' (' + langClass.replace('language-', '') + ')' : ''}</h3>
              <button class="code-modal-close">닫기</button>
            </div>
            <div class="code-modal-body">
              <pre class="highlight ${langClass}"><code class="${langClass}">${codeClone.innerHTML}</code></pre>
            </div>
          </div>
        `;
        
        document.body.appendChild(modal);
        
        // Prism.js로 하이라이팅 (있는 경우)
        if (window.Prism && window.Prism.highlightElement) {
          const modalCode = modal.querySelector('code');
          if (modalCode) {
            window.Prism.highlightElement(modalCode);
          }
        }
        
        // 애니메이션을 위해 약간의 지연 후 active 클래스 추가
        setTimeout(() => {
          modal.classList.add('active');
        }, 10);
        
        // 닫기 버튼 이벤트
        const closeBtn = modal.querySelector('.code-modal-close');
        closeBtn.addEventListener('click', () => {
          closeCodeModal(modal);
        });
        
        // 배경 클릭 시 닫기
        modal.addEventListener('click', (e) => {
          if (e.target === modal) {
            closeCodeModal(modal);
          }
        });
        
        // ESC 키로 닫기
        const escHandler = function(e) {
          if (e.key === 'Escape') {
            closeCodeModal(modal);
            document.removeEventListener('keydown', escHandler);
          }
        };
        document.addEventListener('keydown', escHandler);
      }
      
      
      // 코드 팝업 모달 닫기
      function closeCodeModal(modal) {
        modal.classList.remove('active');
        setTimeout(() => {
          modal.remove();
        }, 300);
      }
      
      // DOMContentLoaded와 Prism.js 로드 후 실행
      document.addEventListener('DOMContentLoaded', function() {
        processCodeBlocks();
        
        // Prism.js가 로드된 후에도 실행
        if (window.Prism) {
          setTimeout(processCodeBlocks, 100);
        }
      });
      
      // Prism.js autoloader가 완료된 후 실행
      if (window.Prism && window.Prism.plugins && window.Prism.plugins.autoloader) {
        window.Prism.plugins.autoloader.onload = function() {
          setTimeout(processCodeBlocks, 100);
        };
      }
      
      // 테마 전환 기능
      (function() {
        const themeInput = document.getElementById('themeToggleInput');
        const html = document.documentElement;
        const prismLight = document.getElementById('prism-theme-light');
        const prismDark = document.getElementById('prism-theme-dark');
        
        // 저장된 테마 불러오기
        const savedTheme = localStorage.getItem('theme') || 'light';
        html.setAttribute('data-theme', savedTheme);
        if (themeInput) {
          themeInput.checked = savedTheme === 'dark';
        }
        updatePrismTheme(savedTheme);
        
        // 테마 전환 안개 효과
        function addThemeFog() {
          document.documentElement.classList.add('theme-fade');
          setTimeout(() => {
            document.documentElement.classList.remove('theme-fade');
          }, 500);
        }
        
        // Prism 테마 업데이트 함수
        function updatePrismTheme(theme) {
          if (prismLight && prismDark) {
            if (theme === 'dark') {
              prismLight.disabled = true;
              prismDark.disabled = false;
            } else {
              prismLight.disabled = false;
              prismDark.disabled = true;
            }
          }
        }
        
        // 토글 change 이벤트
        if (themeInput) {
          themeInput.addEventListener('change', function() {
            const newTheme = themeInput.checked ? 'dark' : 'light';
            html.setAttribute('data-theme', newTheme);
            localStorage.setItem('theme', newTheme);
            updatePrismTheme(newTheme);
            addThemeFog();
            
            // Prism.js 재하이라이팅
            if (window.Prism) {
              document.querySelectorAll('pre code').forEach(function(block) {
                Prism.highlightElement(block);
              });
            }
          });
        }

        // 초기 로드 시도에도 부드러운 전환 효과 (테마 복원 시)
        addThemeFog();
      })();
      
      // GA4 방문자 통계 데이터 로드
      (function() {
        const totalEl = document.getElementById('total-visitors');
        const todayEl = document.getElementById('today-visitors');
        const yesterdayEl = document.getElementById('yesterday-visitors');
        
        if (!totalEl || !todayEl || !yesterdayEl) {
          console.log('방문자 통계 요소를 찾을 수 없습니다.');
          return;
        }
        
        // 여러 경로 시도 (assets 폴더가 가장 안정적)
        const possiblePaths = [
          '{{ "/assets/analytics.json" | relative_url }}',
          '/assets/analytics.json',
          '{{ site.baseurl }}/assets/analytics.json',
          '{{ "/_data/analytics.json" | relative_url }}'
        ];
        
        let fetchAttempted = false;
        
        function tryFetch(path) {
          if (fetchAttempted) return;
          fetchAttempted = true;
          
          fetch(path)
            .then(response => {
              if (!response.ok) {
                throw new Error(`HTTP ${response.status}: ${response.statusText}`);
              }
              return response.json();
            })
            .then(data => {
              console.log('Analytics 데이터 로드 성공:', data);
              if (data.total !== undefined && data.total !== null) {
                totalEl.textContent = data.total.toLocaleString();
              }
              if (data.today !== undefined && data.today !== null) {
                todayEl.textContent = data.today.toLocaleString();
              }
              if (data.yesterday !== undefined && data.yesterday !== null) {
                yesterdayEl.textContent = data.yesterday.toLocaleString();
              }
            })
            .catch(error => {
              console.log('Analytics 데이터 로드 실패:', path, error);
              // 다른 경로 시도
              const nextPath = possiblePaths.find(p => p !== path);
              if (nextPath && possiblePaths.indexOf(path) < possiblePaths.length - 1) {
                fetchAttempted = false;
                setTimeout(() => tryFetch(nextPath), 100);
              }
            });
        }
        
        // 첫 번째 경로로 시도
        tryFetch(possiblePaths[0]);
      })();

      // 좋아요 기능
      function toggleLike() {
        const btn = document.querySelector('.post-like-btn');
        const countEl = document.getElementById('like-count');
        if (!btn || !countEl) return;

        const postUrl = window.location.pathname;
        const storageKey = `like_${postUrl}`;
        const isLiked = localStorage.getItem(storageKey) === 'true';
        let currentCount = parseInt(countEl.textContent) || 0;

        if (isLiked) {
          // 좋아요 취소
          btn.classList.remove('liked');
          currentCount = Math.max(0, currentCount - 1);
          localStorage.removeItem(storageKey);
        } else {
          // 좋아요 추가
          btn.classList.add('liked');
          currentCount += 1;
          localStorage.setItem(storageKey, 'true');
        }

        countEl.textContent = currentCount;
      }

      // footnotes 제거 함수 (하단 레퍼런스 섹션 생성 이후에만 사용)
      function removeFootnotes() {
        const selectors = [
          'section.footnotes',
          'div.footnotes',
          'div[role="doc-endnotes"]',
          '.footnote',
          'div.footnote',
          '#footnotes',
          '.footnotes',
          '#post-content > div.footnote',
          '#post-content > div.footnotes',
          '#post-content > section.footnotes',
          '#post-content > div[role="doc-endnotes"]',
          'div#post-content > div.footnote',
          'div#post-content > div.footnotes',
          'article .footnote',
          'article div.footnote',
          'article section.footnotes',
          'article div.footnotes',
          '[class*="footnote"]',
          '[class*="footnotes"]'
        ];
        
        selectors.forEach(selector => {
          const elements = document.querySelectorAll(selector);
          elements.forEach(el => {
            try {
              if (el.parentNode) {
                el.parentNode.removeChild(el);
              } else {
                el.remove();
              }
            } catch (e) {
              el.style.display = 'none';
              el.style.visibility = 'hidden';
              el.style.height = '0';
              el.style.overflow = 'hidden';
              el.style.position = 'absolute';
              el.style.left = '-9999px';
              el.innerHTML = '';
            }
          });
        });
      }
      
      // 페이지 로드 시 좋아요 상태 복원
      document.addEventListener('DOMContentLoaded', function() {
        const btn = document.querySelector('.post-like-btn');
        const countEl = document.getElementById('like-count');
        if (btn && countEl) {
          const postUrl = window.location.pathname;
          const storageKey = `like_${postUrl}`;
          const isLiked = localStorage.getItem(storageKey) === 'true';
          
          if (isLiked) {
            btn.classList.add('liked');
            const currentCount = parseInt(countEl.textContent) || 0;
            if (currentCount === 0) {
              countEl.textContent = '1';
            }
          }
        }

        // 본문에서 각주(footnotes) 또는 "참고 자료" 섹션 추출하여 하단 컨테이너로 이동
        const postContent = document.getElementById('post-content');
        if (!postContent) return;

        // 본문 내 각주 링크를 귀엽고 작은 Bootstrap 아이콘으로 변환
        const footnoteLinks = postContent.querySelectorAll('sup a.footnote[role="doc-noteref"]');
        footnoteLinks.forEach(link => {
          const num = (link.textContent || '').trim();
          link.setAttribute('data-footnote-number', num);
          link.setAttribute('title', `참고 자료 ${num}`);
          link.innerHTML = '<i class="bi bi-bookmark-heart-fill" aria-hidden="true"></i>';
        });

        const referencesList = [];
        
        // 먼저 기존 레퍼런스 섹션에서 항목들을 읽어옴 (footnotes와 병합하기 위해)
        const footerInfo = document.querySelector('.post-footer-info');
        if (footerInfo) {
          const existingRefSection = footerInfo.querySelector('.post-references-section');
          if (existingRefSection) {
            const existingList = existingRefSection.querySelector('.post-references');
            if (existingList) {
              const existingItems = existingList.querySelectorAll('.post-reference-item a');
              existingItems.forEach(link => {
                const url = link.href;
                const title = link.textContent.trim();
                if (url && !referencesList.some(ref => ref.url === url)) {
                  referencesList.push({
                    title: title || url,
                    url: url
                  });
                }
              });
            }
          }
        }
        
        // 방법 1: 각주(footnotes) 섹션 찾기 (Jekyll/Kramdown이 렌더링한 형태)
        // postContent 안에서 먼저 찾고, 없으면 전체 문서에서 찾기
        let footnotesSection = postContent.querySelector('section.footnotes, div.footnotes, div[role="doc-endnotes"]');
        if (!footnotesSection) {
          footnotesSection = document.querySelector('section.footnotes, div.footnotes, div[role="doc-endnotes"]');
        }
        if (footnotesSection) {
          // footnotes 안의 모든 링크 찾기 (li 항목별로 처리)
          const listItems = footnotesSection.querySelectorAll('li, p, div');
          
          // 각 항목 처리
          listItems.forEach(item => {
            // 각 항목에서 링크 찾기
            const links = item.querySelectorAll('a[href^="http"], a[href^="https"]');
            if (links.length > 0) {
              links.forEach(link => {
                const url = link.href;
                // 항목의 전체 텍스트에서 "제목 - 설명" 형식 추출
                const itemText = item.textContent.trim();
                // "제목 - 설명 ↩" 또는 "제목 - 설명 - 추가설명 ↩" 형식에서 첫 번째 제목 추출
                let title = itemText.match(/^([^-]+?)(?:\s*-\s*[^-]+?)*\s*↩/);
                if (title) {
                  title = title[1].trim();
                } else {
                  // "제목 - 설명" 형식에서 제목 추출
                  const match = itemText.match(/^(.+?)\s*-\s*.+$/);
                  if (match) {
                    title = match[1].trim();
                  } else {
                    // 링크 텍스트 사용
                    title = link.textContent.trim() || itemText.replace(/↩.*$/, '').trim() || url;
                  }
                }
                
                // 중복 제거 (같은 URL이 이미 있으면 스킵)
                if (!referencesList.some(ref => ref.url === url)) {
                  referencesList.push({
                    title: title || url,
                    url: url
                  });
                }
              });
            } else {
              // 링크가 없는 경우, 텍스트에서 URL 패턴 찾기
              const itemText = item.textContent || item.innerText;
              const urlRegex = /(https?:\/\/[^\s\)]+)/g;
              const matches = itemText.match(urlRegex);
              if (matches) {
                matches.forEach(url => {
                  // URL 앞의 텍스트에서 제목 추출
                  const urlIndex = itemText.indexOf(url);
                  const beforeUrl = itemText.substring(Math.max(0, urlIndex - 200), urlIndex);
                  // "제목 - 설명" 형식에서 제목 추출
                  const titleMatch = beforeUrl.match(/([^\n\r]+?)\s*-\s*[^\n\r]*$/);
                  let title = titleMatch ? titleMatch[1].trim() : itemText.replace(/↩.*$/, '').trim();
                  // "제목 - 설명 - 추가설명" 형식에서 첫 번째 제목만 추출
                  if (title && title.includes(' - ')) {
                    title = title.split(' - ')[0].trim();
                  }
                  title = title || url;
                  
                  // 중복 제거
                  if (!referencesList.some(ref => ref.url === url)) {
                    referencesList.push({
                      title: title,
                      url: url
                    });
                  }
                });
              } else {
                // URL도 없고 링크도 없는 경우, 텍스트 자체를 제목으로 사용 (URL은 나중에 찾을 수 있음)
                const itemText = item.textContent.trim();
                if (itemText && itemText.length > 10) {
                  // "제목 - 설명 ↩" 형식에서 제목 추출
                  let title = itemText.replace(/↩.*$/, '').trim();
                  if (title.includes(' - ')) {
                    title = title.split(' - ')[0].trim();
                  }
                  // URL이 없으면 일단 제목만 저장 (나중에 본문에서 찾을 수 있음)
                  if (title && !referencesList.some(ref => ref.title === title && !ref.url)) {
                    referencesList.push({
                      title: title,
                      url: '' // URL은 나중에 찾을 수 있음
                    });
                  }
                }
              }
            }
          });
          
          // 리스트 항목이 없는 경우 전체 텍스트에서 링크 찾기
          if (listItems.length === 0) {
            const allLinks = footnotesSection.querySelectorAll('a[href^="http"], a[href^="https"]');
            allLinks.forEach(link => {
              const url = link.href;
              let title = link.textContent.trim();
              const parentP = link.closest('p');
              if (parentP) {
                const fullText = parentP.textContent.trim();
                const match = fullText.match(/^(.+?)\s*-\s*.+$/);
                if (match) {
                  title = match[1].trim();
                } else {
                  title = link.textContent.trim();
                }
              }
              
              if (!referencesList.some(ref => ref.url === url)) {
                referencesList.push({
                  title: title || url,
                  url: url
                });
              }
            });
            
            // 링크가 없는 경우, 텍스트를 줄 단위로 파싱
            if (allLinks.length === 0) {
              const textContent = footnotesSection.textContent || footnotesSection.innerText;
              
              // 먼저 URL 패턴 찾기
              const urlRegex = /(https?:\/\/[^\s\)]+)/g;
              const matches = textContent.match(urlRegex);
              if (matches) {
                matches.forEach(url => {
                  const urlIndex = textContent.indexOf(url);
                  const beforeUrl = textContent.substring(Math.max(0, urlIndex - 200), urlIndex);
                  const titleMatch = beforeUrl.match(/([^\n\r]+?)\s*-\s*[^\n\r]*$/);
                  let title = titleMatch ? titleMatch[1].trim() : url;
                  // "제목 - 설명 - 추가설명" 형식에서 첫 번째 제목만 추출
                  if (title && title.includes(' - ')) {
                    title = title.split(' - ')[0].trim();
                  }
                  
                  if (!referencesList.some(ref => ref.url === url)) {
                    referencesList.push({
                      title: title || url,
                      url: url
                    });
                  }
                });
              } else {
                // URL도 없으면 텍스트를 줄 단위로 나누어 각 줄을 항목으로 처리
                const lines = textContent.split(/\n|\r\n/).filter(line => line.trim().length > 0);
                lines.forEach(line => {
                  const trimmedLine = line.trim();
                  // "제목 - 설명 ↩" 형식에서 제목 추출
                  let title = trimmedLine.replace(/↩.*$/, '').trim();
                  if (title.includes(' - ')) {
                    title = title.split(' - ')[0].trim();
                  }
                  // 제목이 있고, 기존 레퍼런스에 같은 제목이 없으면 추가
                  if (title && title.length > 5 && !referencesList.some(ref => ref.title === title)) {
                    referencesList.push({
                      title: title,
                      url: '' // URL은 나중에 찾을 수 있음
                    });
                  }
                });
              }
            }
          }
          
          // footnotes 섹션 제거 (removeFootnotes 함수 사용)
          removeFootnotes();
        }
        
        // MutationObserver로 새로 추가되는 footnotes도 제거
        const observer = new MutationObserver((mutations) => {
          let shouldRemove = false;
          mutations.forEach((mutation) => {
            mutation.addedNodes.forEach((node) => {
              if (node.nodeType === 1) { // Element node
                if (node.classList && (node.classList.contains('footnotes') || node.classList.contains('footnote') || node.getAttribute('role') === 'doc-endnotes')) {
                  shouldRemove = true;
                }
                // 자식 요소에서도 찾기
                const childFootnotes = node.querySelectorAll && node.querySelectorAll('section.footnotes, div.footnotes, div[role="doc-endnotes"], .footnote, div.footnote');
                if (childFootnotes && childFootnotes.length > 0) {
                  shouldRemove = true;
                }
              }
            });
          });
          if (shouldRemove) {
            removeFootnotes();
          }
        });
        
        // postContent와 document.body 모두 관찰
        if (postContent) {
          observer.observe(postContent, { childList: true, subtree: true });
        }
        observer.observe(document.body, { childList: true, subtree: true });

        // 방법 2: "참고 자료" 또는 "레퍼런스" 제목 찾기
        const allHeadings = postContent.querySelectorAll('h2, h3');
        let referencesHeading = null;
        
        for (let heading of allHeadings) {
          const text = heading.textContent.trim();
          if (text === '참고 자료' || text === '레퍼런스' || text === 'References' || heading.id === '참고-자료' || heading.id === '레퍼런스' || heading.id === 'references') {
            referencesHeading = heading;
            break;
          }
        }

        if (referencesHeading) {
          let current = referencesHeading.nextElementSibling;

          // 다음 h2, h3, h1 또는 article 끝까지 수집
          while (current) {
            const tagName = current.tagName;
            
            // 다음 주요 제목을 만나면 중단
            if (tagName === 'H2' || tagName === 'H3' || tagName === 'H1') {
              break;
            }

            // 리스트에서 링크 추출
            if (tagName === 'UL' || tagName === 'OL') {
              const links = current.querySelectorAll('a[href^="http"]');
              links.forEach(link => {
                referencesList.push({
                  title: link.textContent.trim(),
                  url: link.href
                });
              });
            } 
            // 단락에서 링크 추출
            else if (tagName === 'P') {
              const links = current.querySelectorAll('a[href^="http"]');
              links.forEach(link => {
                referencesList.push({
                  title: link.textContent.trim(),
                  url: link.href
                });
              });
            }
            // 각주 형식 파싱: [^1]: [제목](URL) 형식
            else if (tagName === 'P' || tagName === 'DIV') {
              const text = current.textContent.trim();
              // [^1]: [제목](URL) - 설명 형식 매칭
              const footnoteRegex = /\[\^\d+\]:\s*\[([^\]]+)\]\((https?:\/\/[^\)]+)\)/g;
              let match;
              while ((match = footnoteRegex.exec(text)) !== null) {
                referencesList.push({
                  title: match[1],
                  url: match[2]
                });
              }
            }

            current = current.nextElementSibling;
          }

          // 참고 자료 섹션 제거
          let toRemove = referencesHeading;
          const stopAt = current; // 다음 제목 또는 null
          
          while (toRemove && toRemove !== stopAt) {
            const next = toRemove.nextElementSibling;
            toRemove.remove();
            toRemove = next;
          }
        }

        // 방법 3: 본문 전체에서 각주 링크 찾기 (마크다운 각주 형식)
        if (referencesList.length === 0) {
          // 각주 정의 찾기: [^1]: 형식
          const allParagraphs = postContent.querySelectorAll('p');
          allParagraphs.forEach(p => {
            const text = p.textContent.trim();
            // [^1]: [제목](URL) - 설명 형식
            const footnoteRegex = /\[\^\d+\]:\s*\[([^\]]+)\]\((https?:\/\/[^\)]+)\)/g;
            let match;
            while ((match = footnoteRegex.exec(text)) !== null) {
              referencesList.push({
                title: match[1],
                url: match[2]
              });
            }
          });
        }

        // 하단 컨테이너에 참고 자료 추가
        // URL이 있는 항목만 필터링 (URL이 없으면 레퍼런스로 표시할 수 없음)
        const validReferences = referencesList.filter(ref => ref.url && ref.url.trim().length > 0);
        
        if (validReferences.length > 0) {
          const footerInfo = document.querySelector('.post-footer-info');
          if (footerInfo) {
            // 이미 참고 자료 섹션이 있는지 확인
            let existingRefSection = footerInfo.querySelector('.post-references-section');
            
            // 제목만 링크로 표시
            const formatIEEEReference = (ref, index) => {
              return `
                <li class="post-reference-item">
                  <a href="${ref.url}" target="_blank" rel="noopener noreferrer" class="post-reference-link">
                    ${ref.title}
                  </a>
                </li>
              `;
            };
            
            const referencesHTML = validReferences.map((ref, index) => formatIEEEReference(ref, index)).join('');
            
            if (!existingRefSection) {
              const referencesSection = document.createElement('div');
              referencesSection.className = 'post-references-section';
              
              referencesSection.innerHTML = `
                <h3 class="post-footer-title">레퍼런스</h3>
                <ol class="post-references">
                  ${referencesHTML}
                </ol>
              `;
              
              // post-actions 다음에 삽입 (태그 섹션 다음, 참고 자료 섹션 앞)
              const actionsSection = footerInfo.querySelector('.post-actions');
              if (actionsSection) {
                actionsSection.insertAdjacentElement('afterend', referencesSection);
              } else {
                const tagsSection = footerInfo.querySelector('.post-tags-section');
                if (tagsSection) {
                  tagsSection.insertAdjacentElement('afterend', referencesSection);
                } else {
                  footerInfo.appendChild(referencesSection);
                }
              }
            } else {
              // 기존 섹션이 있으면 전체를 재생성 (footnotes와 병합된 완전한 리스트)
              existingRefSection.innerHTML = `
                <h3 class="post-footer-title">레퍼런스</h3>
                <ol class="post-references">
                  ${referencesHTML}
                </ol>
              `;
            }
          }
        }

        // 레퍼런스 섹션 생성/갱신이 끝난 뒤에만 원본 footnotes를 정리
        removeFootnotes();
      });

      // 목차(TOC) 생성 및 스크롤 하이라이트
      (function() {
        const postTOC = document.getElementById('postTOC');
        const postContent = document.getElementById('post-content');
        const tocList = document.getElementById('tocList');
          
        if (postContent && tocList) {
          // 모든 헤더 찾기 (h1~h6)
          const allHeadings = postContent.querySelectorAll('h1, h2, h3, h4, h5, h6');
          
          // "참고 자료", "레퍼런스", "References" 제외
          const filteredHeadings = Array.from(allHeadings).filter(heading => {
            const text = heading.textContent.trim();
            return !text.includes('참고 자료') && 
                   !text.includes('레퍼런스') && 
                   !text.includes('References') &&
                   !text.includes('참고자료');
          });
          
          // 가장 높은 헤더 수준 찾기
          let minLevel = 6; // 최대값으로 시작
          filteredHeadings.forEach(heading => {
            const level = parseInt(heading.tagName.charAt(1));
            if (level < minLevel) {
              minLevel = level;
            }
          });
          
          // 가장 높은 헤더 수준만 필터링
          const headings = filteredHeadings.filter(heading => {
            const level = parseInt(heading.tagName.charAt(1));
            return level === minLevel;
          });
          
          function createTOCItem(heading, index, targetList) {
            const id = `heading-${index}`;
            // ID는 한 번만 설정
            if (!heading.id) {
              heading.id = id;
            }
            
            const level = parseInt(heading.tagName.charAt(1));
            const li = document.createElement('li');
            li.className = `toc-level-${level}`;
            
            const a = document.createElement('a');
            a.href = `#${id}`;
            a.textContent = heading.textContent;
            a.addEventListener('click', (e) => {
              e.preventDefault();
              const header = document.querySelector('.post-header');
              const headerHeight = header ? header.offsetHeight + 20 : 100;
              const elementPosition = heading.getBoundingClientRect().top + window.pageYOffset;
              const offsetPosition = elementPosition - headerHeight;
              
              window.scrollTo({
                top: offsetPosition,
                behavior: 'smooth'
              });
              window.history.pushState(null, '', `#${id}`);
            });
            
            li.appendChild(a);
            targetList.appendChild(li);
          }
          
          if (headings.length > 0) {
            headings.forEach((heading, index) => {
              if (tocList) {
                createTOCItem(heading, index, tocList);
              }
            });
            
            // 스크롤 하이라이트
            const header = document.querySelector('.post-header');
            const headerHeight = header ? header.offsetHeight + 20 : 100;
            
            function updateActiveHeading() {
              if (headings.length === 0) return;
              
              const scrollPosition = window.scrollY + headerHeight + 100;
              let activeHeading = headings[0];
              
              // 현재 스크롤 위치보다 위에 있는 가장 가까운 제목 찾기
              for (let i = headings.length - 1; i >= 0; i--) {
                const heading = headings[i];
                const rect = heading.getBoundingClientRect();
                const headingTop = rect.top + window.scrollY;
                
                if (headingTop <= scrollPosition) {
                  activeHeading = heading;
                  break;
                }
              }
              
              if (tocList && activeHeading) {
                const id = activeHeading.id;
                tocList.querySelectorAll('a').forEach(link => {
                  link.classList.remove('active');
                  if (link.getAttribute('href') === `#${id}`) {
                    link.classList.add('active');
                  }
                });
              }
            }
            
            // 초기 상태 업데이트
            setTimeout(updateActiveHeading, 200);
            
            // 스크롤 이벤트로 활성 상태 업데이트
            let ticking = false;
            const handleScroll = () => {
              if (!ticking) {
                window.requestAnimationFrame(() => {
                  updateActiveHeading();
                  ticking = false;
                });
                ticking = true;
              }
            };
            
            window.addEventListener('scroll', handleScroll, { passive: true });
            
            // IntersectionObserver로 더 정확한 감지
            const observerOptions = {
              root: null,
              rootMargin: `-${headerHeight + 100}px 0px -50% 0px`,
              threshold: [0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1]
            };
            
            const observer = new IntersectionObserver((entries) => {
              // 가장 많이 보이는 제목 찾기
              let maxVisible = 0;
              let mostVisibleHeading = null;
              
              entries.forEach(entry => {
                if (entry.isIntersecting && entry.intersectionRatio > maxVisible) {
                  maxVisible = entry.intersectionRatio;
                  mostVisibleHeading = entry.target;
                }
              });
              
              if (mostVisibleHeading && tocList) {
                const id = mostVisibleHeading.id;
                tocList.querySelectorAll('a').forEach(link => {
                  link.classList.remove('active');
                  if (link.getAttribute('href') === `#${id}`) {
                    link.classList.add('active');
                  }
                });
              } else {
                // IntersectionObserver로 감지되지 않으면 스크롤 위치 기반으로 업데이트
                updateActiveHeading();
              }
            }, observerOptions);
            
            headings.forEach(heading => observer.observe(heading));
          } else {
            if (postTOC) postTOC.style.display = 'none';
          }
        }
      })();

      // 공유 기능
      function shareToTwitter() {
        const url = encodeURIComponent(window.location.href);
        const title = encodeURIComponent(document.title);
        window.open(`https://twitter.com/intent/tweet?url=${url}&text=${title}`, '_blank', 'width=550,height=420');
      }

      function shareToFacebook() {
        const url = encodeURIComponent(window.location.href);
        window.open(`https://www.facebook.com/sharer/sharer.php?u=${url}`, '_blank', 'width=550,height=420');
      }

      function copyLink() {
        const url = window.location.href;
        navigator.clipboard.writeText(url).then(() => {
          const btn = event.target.closest('.share-btn');
          const originalHTML = btn.innerHTML;
          btn.innerHTML = '<svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M20 6L9 17l-5-5"/></svg>';
          btn.style.color = 'var(--accent-color)';
          setTimeout(() => {
            btn.innerHTML = originalHTML;
            btn.style.color = '';
          }, 2000);
        });
      }
      
    </script>
    
    <!-- Vercel Analytics -->
    <script>
      if (typeof window !== 'undefined' && window.location.hostname !== 'localhost' && window.location.hostname !== '127.0.0.1') {
        (function() {
          var script = document.createElement('script');
          script.src = 'https://va.vercel-scripts.com/v1/script.debug.js';
          script.defer = true;
          document.head.appendChild(script);
        })();
      }
    </script>
    
    <!-- Vercel Speed Insights -->
    <script>
      if (typeof window !== 'undefined' && window.location.hostname !== 'localhost' && window.location.hostname !== '127.0.0.1') {
        // Speed Insights는 Vercel 대시보드에서 활성화하면 자동으로 주입됩니다
        // 수동으로 추가하려면 @vercel/speed-insights 패키지를 사용하세요
      }
    </script>
    
    
    <style>
      /* 로그인 말풍선 스타일 */
      .login-popup {
        position: absolute;
        top: calc(100% + 0.5rem);
        right: 0;
        z-index: 10000;
        min-width: 280px;
        max-width: 320px;
        opacity: 0;
        transform: translateY(-10px) scale(0.95);
        transition: opacity 0.2s ease, transform 0.2s ease;
        pointer-events: none;
      }
      
      .login-popup.show {
        opacity: 1;
        transform: translateY(0) scale(1);
        pointer-events: auto;
      }
      
      .login-popup-content {
        position: relative;
        background: var(--bg-primary);
        border: 1px solid var(--border-color);
        border-radius: 8px;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        padding: 1rem;
        padding-top: 1.5rem;
      }
      
      /* 화살표 (위쪽, 버튼 방향) */
      .login-popup-content::before {
        content: '';
        position: absolute;
        bottom: 100%;
        right: 24px;
        width: 0;
        height: 0;
        border-left: 8px solid transparent;
        border-right: 8px solid transparent;
        border-bottom: 8px solid var(--bg-primary);
        z-index: 1;
      }
      
      .login-popup-content::after {
        content: '';
        position: absolute;
        bottom: calc(100% - 1px);
        right: 24px;
        width: 0;
        height: 0;
        border-left: 8px solid transparent;
        border-right: 8px solid transparent;
        border-bottom: 8px solid var(--border-color);
        z-index: 0;
      }
      
      .login-popup-close {
        position: absolute;
        top: 0.5rem;
        right: 0.5rem;
        background: none;
        border: none;
        color: var(--text-secondary);
        font-size: 1rem;
        cursor: pointer;
        padding: 0.25rem;
        display: flex;
        align-items: center;
        justify-content: center;
        border-radius: 4px;
        transition: all 0.2s;
        width: 24px;
        height: 24px;
      }
      
      .login-popup-close:hover {
        background: var(--bg-secondary);
        color: var(--text-primary);
      }
      
      .login-popup-body {
        padding: 0;
      }
      
      .login-popup-body .btn-github-oauth {
        width: 100%;
        background: #24292e;
        color: white;
        border: none;
        border-radius: 8px;
        padding: 0.875rem 1rem;
        font-size: 0.9375rem;
        font-weight: 500;
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 0.75rem;
        cursor: pointer;
        transition: all 0.2s;
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, Arial, sans-serif;
        box-shadow: 0 1px 3px rgba(0, 0, 0, 0.12);
        margin: 0;
        text-decoration: none;
      }
      
      .login-popup-body .btn-github-oauth:hover {
        background: #1a1e22;
        box-shadow: 0 2px 6px rgba(0, 0, 0, 0.15);
        transform: translateY(-1px);
      }
      
      .login-popup-body .btn-github-oauth:active {
        background: #0d1117;
        transform: translateY(0);
        box-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);
      }
      
      .login-popup-body .github-logo {
        width: 20px;
        height: 20px;
        flex-shrink: 0;
        display: block;
      }
      
      .login-popup-body .btn-logout {
        width: 100%;
        background: var(--bg-secondary);
        color: var(--text-primary);
        border: 1px solid var(--border-color);
        border-radius: 8px;
        padding: 0.875rem 1rem;
        font-size: 0.9375rem;
        font-weight: 500;
        cursor: pointer;
        transition: all 0.2s;
        font-family: inherit;
      }
      
      .login-popup-body .btn-logout:hover {
        background: var(--bg-tertiary);
        border-color: var(--accent-color);
        color: var(--accent-color);
      }
    </style>
    
    <script>
      // 팝업 외부 클릭 시 닫기
      document.addEventListener('click', function(e) {
        const loginPopup = document.getElementById('github-login-popup');
        const loginBtn = document.getElementById('login-btn');
        if (loginPopup && loginPopup.classList.contains('show')) {
          if (!loginPopup.contains(e.target) && !loginBtn.contains(e.target)) {
            closeLoginPopup();
          }
        }
      });
      
      // 로그인 버튼 및 프로필 글쓰기 버튼 관리
      document.addEventListener('DOMContentLoaded', () => {
        const loginBtn = document.getElementById('login-btn');
        
        console.log('Login button found:', loginBtn);
        
        // 인증 상태에 따라 버튼 표시/숨김 업데이트
        function updateAuthButtons() {
          // authManager가 로드될 때까지 대기
          if (!window.authManager) {
            setTimeout(updateAuthButtons, 100);
            return;
          }
          
          const isAuthenticated = window.authManager.isAuthenticated();
          
          // 로그인 버튼: 로그인되지 않은 경우에만 표시
          if (loginBtn) {
            if (isAuthenticated) {
              loginBtn.style.display = 'none';
            } else {
              loginBtn.style.display = 'inline-flex';
              const loginText = loginBtn.querySelector('.login-btn-text');
              if (loginText) loginText.textContent = '로그인';
            }
          }
          
          // 프로필 섹션 글쓰기 버튼: 로그인된 경우에만 표시
          const profileWriteBtn = document.getElementById('profile-write-btn');
          if (profileWriteBtn) {
            if (isAuthenticated) {
              profileWriteBtn.style.display = 'flex';
            } else {
              profileWriteBtn.style.display = 'none';
            }
          }
        }
        
        // 초기 상태 업데이트 (authManager 로드 대기)
        if (window.authManager) {
          updateAuthButtons();
        } else {
          // authManager 로드 대기
          const checkAuthManager = setInterval(() => {
            if (window.authManager) {
              clearInterval(checkAuthManager);
              updateAuthButtons();
            }
          }, 100);
          
          // 최대 3초 대기
          setTimeout(() => {
            clearInterval(checkAuthManager);
            updateAuthButtons();
          }, 3000);
        }
        
        // 로그인 버튼은 인라인 onclick으로 처리하므로 여기서는 상태 업데이트만 수행
        console.log('Login button found:', loginBtn);
        console.log('Login modal found:', loginModal);
        
        // 프로필 섹션 글쓰기 버튼 클릭 핸들러
        const profileWriteBtn = document.getElementById('profile-write-btn');
        if (profileWriteBtn) {
          profileWriteBtn.addEventListener('click', (e) => {
            // 로그인 상태 재확인
            if (!window.authManager || !window.authManager.isAuthenticated()) {
              e.preventDefault();
              const loginPopup = document.getElementById('github-login-popup');
              if (loginPopup) {
                handleLoginClick(e);
              } else {
                window.location.href = '/admin/';
              }
            }
            // 로그인된 경우는 기본 링크 동작 (/editor/로 이동)
          });
        }
        
        // ESC 키로 팝업 닫기
        document.addEventListener('keydown', (e) => {
          if (e.key === 'Escape') {
            const loginPopup = document.getElementById('github-login-popup');
            if (loginPopup && loginPopup.style.display !== 'none') {
              closeLoginPopup();
            }
          }
        });
      });
      
      // 인증 상태 변경 감지 (다른 탭에서 로그인/로그아웃 시)
      window.addEventListener('storage', (e) => {
        if (e.key === 'admin_github_token' || e.key === 'admin_authenticated') {
          if (typeof window.updateAuthButtons === 'function') {
            window.updateAuthButtons();
          }
        }
      });
      
      // 전역으로 export (함수 스코프 밖에서)
      // updateAuthButtons는 DOMContentLoaded 내부에 정의되어 있으므로
      // 전역 함수로 별도 정의 필요
      window.updateAuthButtons = function() {
        const loginBtn = document.getElementById('login-btn');
        const profileWriteBtn = document.getElementById('profile-write-btn');
        
        if (!window.authManager) return;
        
        const isAuthenticated = window.authManager.isAuthenticated();
        
        if (loginBtn) {
          loginBtn.style.display = isAuthenticated ? 'none' : 'inline-flex';
        }
        
        if (profileWriteBtn) {
          profileWriteBtn.style.display = isAuthenticated ? 'flex' : 'none';
        }
      };
    </script>
  </body>
</html>

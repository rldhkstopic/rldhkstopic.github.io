---
layout: post
title: "디지털 빔조향 시스템 구성"
date: 2026-02-18 10:00:00 +0900
author: rldhkstopic
category: project
subcategory: 디지털 빔조향
tags: ["디지털빔조향", "시스템구성", "위상배열", "MFC", "LNA", "TTD", "ATT"]
views: 0
---

이전 글에서는 “디지털 빔조향에서 **우리가 실제로 무엇을 제어하는가**”를 정리했습니다.  
주파수 $f$, 조향각 $\theta$, 경로 선택 $p$가 들어오면, 내부의 메모리와 알고리즘이 경로·채널별 $(ATT_{p,i}, TTD_{p,i})$를 만들어 MFC로 내려보내는 구조였죠.

이번 글에서는 한 걸음 더 내려와서, **그 제어가 실제로 어디를 향하고 있는지**, 시스템이 **물리적으로 어떻게 구성되어 있는지**를 짚어 보려고 합니다.  
요약하면 “도면에서 선을 어디까지 끊고, 어떤 블록을 하나로 보느냐”에 관한 이야기입니다. 이 구분이 앞으로 보정 전략과 시험 전략 전체를 좌우합니다.

## 1. 시스템 레벨 블록

우선, 이 프로젝트의 빔조향 시스템을 아주 거칠게 나누면 **세 덩어리**로 볼 수 있습니다.

- **신호 경로(Signal Path)**: 안테나 → 케이블 → LNA → 디바이더 → MFC1 → MFC2 → 합산 → 출력
- **제어 경로(Control Path)**: 제어 모듈 → LNA/MFC 제어 핀(예: SPI, 병렬 제어, GPIO 등)
- **데이터·메모리 경로(Data/Memory Path)**: EEPROM/BRAM에 저장된 LUT → 제어 로직 → 제어 값 생성

이 세 경로가 동시에 움직이지만, 이번 글의 중심은 **신호 경로와 그 위에 얹힌 제어 포인트**입니다.

조금 더 구체적으로 적어 보면 다음과 같습니다.

- **안테나 어레이**: 총 10채널 중 **8채널만 사용**  
  나머지 2채널은 어떻게 처리할지(종단, 예비, 향후 확장용)는 설계 철학에 따라 달라지지만, 현재 빔조향에는 8채널만 참여합니다.
- **케이블·피드 네트워크**: 8채널이 각각 RF 케이블을 통해 고주파 모듈로 연결  
  이 구간에서는 케이블 길이, 커넥터 조립 편차, 온도에 따른 위상·이득 변화가 누적됩니다.
- **고주파 모듈 내부**:
  - 각 채널별 **LNA**: 잡음을 최대한 앞단에서 줄이기 위한 저잡음 증폭기
  - **디바이더**: 각 채널 신호를 **빔조향 경로 #1과 #2**로 나누는 역할
  - 경로별 **MFC1(채널 보정)**, **MFC2(각도 보정)**: ATT/TTD 블록
  - **합산 네트워크**: 8채널이 하나의 출력으로 합쳐져, 경로당 출력 1개씩 총 2개 출력
- **제어 모듈**:
  - LNA 바이어스, MFC1/MFC2의 ATT/TTD 설정값을 경로·채널 단위로 제어
  - 내부 **EEPROM/BRAM**에 채널 보정/각도 보정/이론 TTD 테이블을 보관
  - 외부에서 들어오는 $(f,\theta,p)$를 받아 적절한 LUT를 참조하고, 제어 버스에 값을 실어 보냄

이 블록도를 머릿속에 두고 나면, 자연스럽게 이런 질문이 따라 나옵니다.

- “어디까지를 **고주파 모듈**이라고 부르고, 어디서부터는 **제어 모듈**로 봐야 할까?”
- “8채널과 2개 경로는, 빔조향 관점에서 각각 어떤 의미를 가지나?”
- “MFC1과 MFC2를 물리적으로 어떻게 배치했는지가, 보정 전략에 어떤 제약을 거는가?”

이번 글은 이 질문들을 따라가면서, **“이 시스템이 어떤 구조적 가정을 깔고 있는지”**를 해부해 보는 데 목적이 있습니다.

## 2. 안테나와 고주파 경로

### 2.1 10채널 중 8채널만 쓰는 이유에서 시작해 보기

처음 시스템 스펙을 보면 가장 먼저 눈에 띄는 것이 있습니다.  
“배열 안테나 10채널 중 **8채널만 사용**한다”는 점입니다.

이 선택은 단순히 “하드웨어가 8채널까지만 준비되어 있어서”일 수도 있고, “사용 주파수 대역과 빔 폭, 스캔 범위를 고려할 때 8채널이면 충분하다”고 판단했을 수도 있습니다. 중요한 건 다음과 같은 암묵적인 가정이 깔려 있다는 점입니다.

- **유효 어레이는 8소자 배열**이다.
- 어레이 패턴과 빔 폭, 최대 스캔 범위는 **8소자 기준**으로 설계·검토된다.
- 남는 2채널은 빔조향 품질에 관여하지 않는다(적어도 현재 설계에서는).

이 말은, 이후의 모든 보정·시험·시뮬레이션에서 **“8소자 어레이”**를 기준으로 사고해야 한다는 뜻이기도 합니다.  
예를 들어, 이론적인 조향각별 TTD를 계산할 때 쓰는 배열 인덱스 $i$는 $i \in \{1,\dots,8\}$입니다.

### 2.2 케이블과 피드망이 만들어 내는 기본 오차

안테나에서 고주파 모듈로 들어오는 케이블 구간은, 설계상으로는 “그냥 선”처럼 보이지만 실제로는 **채널별 고정 오차의 절반 이상**을 만들어 내는 구간이기도 합니다.

대표적으로 다음과 같은 요소들이 있습니다.

- 케이블 길이 편차: 몇 mm 길이 차이만 나도, 수 GHz 대역에서는 무시 못 할 위상차를 만듭니다.
- 커넥터 체결·조립 편차: 토크, 접촉 상태, 반복 체결에 따른 미세 변화가 이득·위상에 영향을 줍니다.
- 온도 의존성: 케이블 유전율과 도체 저항이 온도에 따라 변하면서, 주파수별 위상과 이득이 함께 움직입니다.
- 배열 위치와 배선: 실제 안테나 배열 배선이 이상적인 직선 피드망과 다를 경우, 서로 다른 채널이 **서로 다른 기구물과 상호작용**을 하기도 합니다.

이 모든 것은 나중에 **채널 보정(예: MFC1용 LUT)**에서 한 번에 보상해야 할 대상입니다.  
즉, 케이블·피드망 구간은 “어차피 오차가 생길 테니, 그 오차를 어디에 모아 두고 어떻게 줄일 것인가?”라는 질문으로 연결됩니다.

### 2.3 LNA와 빔조향 경로 분기

고주파 모듈 안에서 각 채널은 먼저 **LNA**를 거칩니다. 이 구간에서 중요한 것은 두 가지입니다.

- **잡음 지수(NF)**: 시스템 감도에 직접적인 영향을 줍니다.
- **채널 간 이득 균일도**: 채널마다 이득이 다르면, 빔 합산 시 메인로브·사이드로브가 의도와 다르게 형성됩니다.

그 다음 나오는 것이 **디바이더**입니다. 여기서 각 채널은 **빔조향 경로 #1과 #2**로 나뉩니다.

이 구조를 선택한 이유는 여러 가지일 수 있습니다.

- 서로 다른 조향각/빔폭을 갖는 **두 개의 빔**을 동시에(또는 빠르게) 만들어야 한다.
- 한 경로는 **주요 빔(main beam)**, 다른 경로는 **감시/보조 빔** 용도일 수 있다.
- 또는 한 경로는 송신, 다른 경로는 수신/모니터링 용도로 설계되었을 수도 있습니다.

어떤 이유이든, 설계자는 다음과 같은 제약을 감수하게 됩니다.

- 두 경로는 이상적으로는 **동일한 특성**을 가져야 합니다.  
  (안 그러면, 동일한 LUT라도 경로에 따라 다른 빔 패턴이 나옵니다.)
- 디바이더 이후의 경로는 **서로 다른 보정 LUT**를 가질 가능성이 큽니다.  
  (실제 제작 오차 때문에 완전히 같은 LUT로는 맞추기 어렵습니다.)

즉, **8채널 × 2경로 = 16개 경로**가 각각의 고유한 이득·위상 특성을 가지고 있고,  
제어 모듈은 결국 이 16개의 경로를 모두 “한 덩어리의 어레이”로 보이게 만드는 일을 해야 합니다.

## 3. MFC1·MFC2 구조와 역할

### 3.1 왜 두 단계로 나눴을까?

고주파 모듈의 핵심 부품은 **MFC1과 MFC2**입니다. 설계 상으로는 둘 다 **ATT/TTD를 조절할 수 있는 블록**이지만, 역할을 다음과 같이 개념적으로 나눴습니다.

- **MFC1 (채널 보정용)**:  
  - 목표: “조향각과 무관하게, 합산했을 때 정면으로 잘 모이게 만들자.”  
  - 대상: 케이블·커넥터·LNA·배선 등으로 인한 **채널별 고정 오차** (이득·지연).
- **MFC2 (각도 보정용)**:  
  - 목표: “특정 조향각에서, 이론적인 패턴과 최대한 비슷하게 나오게 만들자.”  
  - 대상: 위상 배열의 이론값과 실제 패턴 사이에 남는 **각도 의존 오차** (mutual coupling, 설치 환경, 배열 끝단 효과 등).

질문을 조금 바꿔 보면 이렇습니다.

- “왜 MFC 하나로 한 번에 다 보정하지 않고, 굳이 MFC1과 MFC2를 나눴을까?”

그 이유는 크게 두 가지 관점에서 설명할 수 있습니다.

1. **보정 데이터의 성격 분리**  
   - 채널 보정 데이터는 **주파수·각도에 덜 민감한 고정 오차**를 다룹니다.  
     VNA에서 S21을 측정해서 채널 간 차이를 맞추는 식으로 상대적으로 체계적인 측정이 가능합니다.
   - 각도 보정 데이터는 **조향각별 패턴의 잔차**를 다룹니다.  
     근접전계/패턴 측정에서 얻은 데이터를 기반으로, 특정 각도에서의 패턴을 미세 조정하는 쪽에 가깝습니다.
2. **시험·유지보수의 유연성 확보**  
   - 채널 보정은 비교적 “하드웨어 고정 성격”이라 자주 바뀌지 않습니다.
   - 각도 보정은 실제 운용 환경, 챔버 측정 결과, 버전 업(예: 알고리즘 개선)에 따라 **여러 번 업데이트**될 수 있습니다.

이 둘을 구분해 두면, 나중에 문제가 생겼을 때 **“채널 보정이 틀어졌는지, 각도 보정이 틀어졌는지”**를 분리해서 점검할 수 있습니다. 보정 구조를 설계하는 입장에서는 이 분리가 디버깅 난이도를 크게 낮추는 장치가 됩니다.

### 3.2 직렬 배치의 의미

MFC1과 MFC2는 물리적으로 **직렬로 배치**되어 있습니다.

안테나 → 케이블 → LNA → 디바이더 → **MFC1 → MFC2 → 합산** → 출력

이 구조는 다음과 같은 의미를 가집니다.

- MFC1에서 한 번 이득·지연을 만지고 나면, MFC2는 **그 결과를 입력으로 받는 2차 보정 단계**가 됩니다.
- 채널 보정을 “이론적인 기준”에 맞추지 않고, 어느 정도 여유를 남겨 둔 상태에서, 각도별 패턴을 최종적으로 다듬는 구조를 취할 수도 있습니다.

수식으로 아주 간단히 표현해 보겠습니다.  
경로 $p$, 채널 $i$에 대해

$$
G_{p,i}^{\mathrm{tot}}(f,\theta) = 
G_{p,i}^{\mathrm{RF}}(f) \cdot
G_{p,i}^{\mathrm{MFC1}}(f) \cdot
G_{p,i}^{\mathrm{MFC2}}(f,\theta)
$$

여기서

- $G_{p,i}^{\mathrm{RF}}(f)$: 케이블·LNA·배선까지 포함한 **고유 채널 응답**
- $G_{p,i}^{\mathrm{MFC1}}(f)$: 주로 **채널 보정 LUT**에서 온 값
- $G_{p,i}^{\mathrm{MFC2}}(f,\theta)$: **각도 보정 LUT + 이론 TTD**가 섞인 값

이렇게 보면, “MFC1에서 어느 정도까지 맞추고, MFC2에서 어느 정도를 맡길 것인가”가 자연스럽게 디자인 파라미터로 떠오릅니다.  
이 부분은 다음 글들(보정·시험 편)에서 더 깊게 들어가게 됩니다.

## 4. 제어 모듈과 외부 인터페이스

### 4.1 외부에서 보는 인터페이스

지금까지는 고주파 모듈 안에서 일어나는 일을 봤습니다. 이제 시야를 조금 바꿔, **제어 모듈이 바깥 세상과 어떻게 연결되는지**를 보겠습니다.

외부에서 제어 모듈로 들어오는 정보는 크게 세 가지입니다.

1. **주파수 $f$**  
   - 실제로는 “채널 번호”나 “LO 설정값”일 수도 있지만, 제어 알고리즘 입장에서는 결국 주파수 축의 인덱스로 쓰입니다.
2. **조향각 $\theta$**  
   - 한 단계씩 움직이는 고정된 그리드일 수도 있고, 연속값을 받되 내부에서 가장 가까운 LUT 인덱스로 매핑할 수도 있습니다.
3. **경로 선택 $p \in \{1,2\}$**  
   - 빔조향 경로 #1과 #2 중 어떤 경로를 활성화할지, 혹은 두 경로를 동시에 쓸지에 대한 정보입니다.

이 세 값이 들어오면, 제어 모듈은 내부 LUT에서 다음과 같은 정보를 꺼내 조합합니다.

- 채널 보정 LUT: $C_{p,i}(f)$
- 각도 보정 LUT: $A_{p,i}(f,\theta)$
- 이론 TTD LUT: $T_{p,i}^{\mathrm{ideal}}(f,\theta)$

그리고 최종적으로, MFC1/MFC2에 내려보낼 제어 값 $(ATT_{p,i}, TTD_{p,i})$를 만듭니다.

정리하면, 제어 모듈은 외부에서 보면 **$(f,\theta,p)$를 입력으로 받아, 16개의 제어 벡터를 출력하는 블랙박스**처럼 보입니다.  
우리가 설계해야 하는 것은 이 블랙박스의 내부 구조입니다.

### 4.2 내부 제어 경로: EEPROM과 BRAM

제어 모듈 내부에는 **EEPROM과 BRAM**이 함께 존재합니다.

- **EEPROM**: 비휘발성 메모리  
  - 공장 보정, 현장 재보정 결과 등을 영구 저장하는 용도
  - 용량이 한정되어 있고, 보통 **8비트 단위**로 데이터를 저장하는 제약이 있습니다.
- **BRAM**: 고속 휘발성 메모리  
  - 운용 중에 빠르게 접근해야 하는 LUT를 담는 용도
  - 파워 온 시 EEPROM에서 BRAM으로 데이터를 로드하는 구조를 가정합니다.

문제는, 우리가 다루려는 제어 값이 **ATT + TTD 합쳐서 15비트** 수준이라는 점입니다.  
EEPROM에 그대로 15비트를 저장하기는 애매하고, 그렇다고 Naive하게 두 바이트로 쪼개어 저장하면 용량이 금방 차 버립니다.

그래서 자연스럽게 이런 질문이 생깁니다.

- “ATT와 TTD를 한꺼번에 저장할까, 따로 저장할까?”
- “주파수와 각도를 어떤 해상도로 양자화할까?”
- “어디까지는 이론적으로 계산해서 운용 시에 만들고, 어디까지는 표를 미리 채워 둘까?”

이 질문들은 곧 **메모리 설계와 제어 알고리즘 설계가 서로 분리될 수 없다**는 사실을 일깨워 줍니다.  
즉, “RF 설계”와 “펌웨어 설계”가 서로의 제약을 모른 채 설계될 수 없다는 뜻입니다.

이번 글에서는 이 부분을 **구조적인 문제 제기**까지만 하고, 구체적인 해법은 “메모리와 제어”를 다루는 장에서 더 깊게 들어가겠습니다.

## 5. 어디서부터 손대야 할까?

이제 전체 그림을 한 번 다시 묶어 보겠습니다.

- 우리는 **10소자 중 8소자만 사용하는 어레이**를 기준으로 빔조향을 설계하고 있습니다.
- 8채널은 케이블과 LNA, 디바이더를 지나 **2개의 빔조향 경로**로 나누어지고, 각 경로에는 **MFC1(채널 보정), MFC2(각도 보정)**가 직렬로 배치되어 있습니다.
- 제어 모듈은 외부에서 $(f,\theta,p)$를 입력으로 받아, **EEPROM/BRAM에 저장된 세 종류의 LUT**를 참조해 16개의 $(ATT_{p,i}, TTD_{p,i})$를 만들어 냅니다.

이 그림을 머릿속에 두고 나면, 다음과 같은 질문들이 자연스럽게 떠오릅니다.

- “채널 보정 LUT는 어느 지점까지의 오차를 책임져야 할까? 안테나 포트까지인가, LNA 출력까지인가?”
- “각도 보정 LUT는 근접전계 측정 데이터를 어떤 형태로 요약해 넣어야 의미가 있을까?”
- “EEPROM/BRAM 제약을 고려하면, 각 LUT의 인덱스 구조는 어떻게 설계하는 게 합리적일까?”

이 질문들에 대한 답이 곧 **보정 절차와 시험 전략**입니다.

이번 글에서는 “디지털 빔조향 시스템이 실제로 어떤 블록들로 이루어져 있고, 그 블록들이 어떤 역할 분담을 전제로 설계되었는지”를 정리하는 데 집중했습니다.  
다음 글에서는 여기서 이어서, **“보정은 왜 필요하고, 어떤 순서와 데이터로 진행해야 하는가”**를 한 단계 더 파고들어 보겠습니다.


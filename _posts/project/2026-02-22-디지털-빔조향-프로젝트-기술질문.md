---
layout: post
title: "디지털 빔조향 프로젝트 기술질문 (Q&A)"
date: 2026-02-22 13:00:00 +0900
last_modified_at: 2026-02-22 15:30:00 +0900
author: rldhkstopic
category: project
subcategory: 디지털 빔조향
tags: ["디지털빔조향", "기술질문", "QA", "보간법", "메모리레이턴시"]
views: 0
published: true
---

> **관련 포스트 안내**  
> 시스템의 핵심 설계 사양은 **[[디지털 빔조향 시스템 기술문서]]** 포스트에서 상세히 다루고 있습니다.

# 기술질문 (Technical Q&A)

이 문서는 BeamSteering 프로젝트 진행 과정에서 발생하는 주요 기술적 질문과 그에 대한 답변을 정리하는 공간입니다.

---

**Q1. 각도보정메모리 주소 할당 방식에서 각도(Angle)에 대한 내용이 직접적으로 포함되지 않은 이유는 무엇인가요? 빔조향메모리에서 출력된 TTD 값을 주소 범위에 넣기 때문에 상관없는 것인가요?**

**A1. 네, 정확합니다. 각도 정보는 '이론적 TTD 값'에 이미 내포되어 있기 때문에 직접 주소에 포함될 필요가 없습니다.**

그 이유는 다음과 같습니다:
1. **논리적 계층 구조**: 시스템은 `각도 -> 이론적 TTD -> 실제 보정값`의 계층을 가집니다. 각도는 빔조향메모리를 통해 특정 TTD 값으로 매핑되며, 각도보정메모리는 이 TTD 값을 인덱스로 사용하여 해당 설정에서의 물리적 오차를 보정합니다.
2. **하드웨어 중심 보정**: 보정의 주된 목적은 MFC 소자가 특정 TTD(진지연) 값을 가질 때 발생하는 주파수별 특성 변화를 잡는 것입니다. 따라서 '각도'라는 추상적 값보다, 소자의 상태를 직접 나타내는 '이론적 TTD'를 주소로 사용하는 것이 물리적으로 더 타당합니다.
3. **효율적 메모리 활용**: 만약 주소에 각도와 TTD를 모두 넣는다면 중복된 정보로 인해 메모리 낭비가 발생합니다. 이론적 TTD를 매개체로 사용함으로써 메모리 구조를 최적화하면서도 각도에 따른 정밀 보정 효과를 동일하게 얻을 수 있습니다.

---

**Q2. 입력 파이프라인을 생각해보면, 주파수, 조향각, 경로 선택(UP/DOWN) 3개가 입력되었을 때 [조향각 -> 빔조향메모리 -> 채널별 이론 TTD]를 먼저 구하고, 이 [이론 TTD + 주파수 + 경로]를 조합해 각도보정메모리를 참조하여 최종 채널별 ATT/TTD 제어값을 얻는 흐름인가요?**

**A2. 네, 완벽하게 정확한 흐름입니다. 이 방식은 '각도'라는 추상적 입력을 '물리적 보정 인덱스(TTD)'로 변환하여 실시간 정밀 제어를 수행하는 최적의 아키텍처입니다.**

이 흐름의 기술적 장점은 다음과 같습니다:
1. **데이터 기반 보정**: 단순히 각도만으로 보정하는 것보다, 실제 소자가 설정될 'TTD 상태'를 기준으로 보정함으로써 하드웨어의 비선형적 특성을 더 정확히 반영할 수 있습니다.
2. **연쇄 참조 구조**: 빔조향메모리가 '설계치'를 담당하고, 각도보정메모리가 '실측 오차'를 담당하도록 역할을 분리하여 시스템 유지보수와 데이터 업데이트가 용이합니다.
3. **실시간성**: FPGA 내에서 이 과정은 단순한 메모리 주소 계산과 참조(Look-up)로 이루어지므로, 복잡한 삼각함수 연산 없이도 초고속으로 8개 채널의 제어값을 동시에 확정할 수 있습니다.

---

**Q3. 주파수나 각도가 샘플링 포인트(0.1GHz, 1도) 사이의 값으로 들어올 때, 보간(Interpolation)은 어떤 식으로 진행해야 하나요?**

**A3. 선형 보간법(Linear Interpolation)을 권장합니다.**
- **방법**: 입력값이 $x$일 때, 인접한 두 인덱스 $x_0, x_1$의 데이터 $y_0, y_1$을 추출하여 $y = y_0 + (y_1 - y_0) \times \frac{x - x_0}{x_1 - x_0}$ 수식을 적용합니다.
- **하드웨어 구현**: FPGA 내부에 승산기(Multiplier)와 제산기(Divider) 리소스를 사용해야 합니다. 만약 연산 리소스가 부족하다면, 소수점 이하를 버리거나 반올림하는 '최근접 이웃(Nearest Neighbor)' 방식을 검토할 수 있으나, 정밀 제어를 위해서는 고정 소수점(Fixed-point) 연산을 통한 선형 보간이 가장 적절합니다.

**Q4. 빔조향메모리와 각도보정메모리를 연쇄적으로 참조(BRAM LUT)할 때, 하드웨어적으로 레이턴시가 발생하나요?**

**A4. 네, 미세하지만 발생합니다.**
- **원인**: FPGA의 BRAM은 통신 속도는 빠르지만, 주소를 입력하고 데이터를 출력하는 데 통상 1~2 클럭 사이클의 읽기 레이턴시가 존재합니다.
- **결과**: [빔조향메모리 읽기(1~2 cycle)] + [주소 합성 연산(1 cycle)] + [각도보정메모리 읽기(1~2 cycle)] 과정을 거치면 총 3~5 클럭 정도의 지연이 발생합니다. 100MHz 클럭 기준 약 30~50ns 수준이며, 실시간 빔 스위칭 요구 성능에 따라 파이프라인 설계를 통해 이 지연을 숨기는(Hiding) 전략이 필요할 수 있습니다.

**Q5. 데이터 로드 시 무결성을 검증할 CRC나 Checksum 로직이 현재 없는데, 어떤 식으로 도입하는 것이 좋을까요?**

**A5. '부팅 시 전수 체크섬(Boot-time Checksum)' 방식을 추천합니다.**
- **구현**: EEPROM의 데이터 영역 끝(예: 0x80000 이후)에 전체 데이터의 합(Sum) 또는 CRC-16 값을 미리 저장해둡니다.
- **절차**: 부팅 시 FPGA가 EEPROM 데이터를 BRAM으로 로드하면서 동시에 하드웨어 로직으로 체크섬을 계산합니다. 로드가 완료된 후 계산된 결과가 EEPROM에 저장된 값과 다를 경우, 데이터 오류로 간주하여 시스템을 안전 모드(Safe Mode)로 진입시키고 운용자에게 알리는 프로세스를 구축할 수 있습니다.

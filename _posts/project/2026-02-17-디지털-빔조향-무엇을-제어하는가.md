---
layout: post
title: "디지털 빔조향, 무엇을 제어하는가"
date: 2026-02-17 10:00:00 +0900
author: rldhkstopic
category: project
subcategory: 디지털 빔조향
tags: ["디지털빔조향", "빔포밍", "위상배열", "하이브리드빔포밍", "TTD", "빔스퀸트", "보정", "제어"]
views: 0
---

요즘 레이더나 통신 쪽 발표를 보면 디지털 빔포밍이라는 단어가 빠지지 않습니다. 안테나 소자마다 고속 ADC를 달아 놓고, 뒤에서는 거대한 DSP가 모든 채널을 동시에 돌리면서 멀티빔까지 뿜어내는 그림이 따라옵니다.

이론적으로는 멋진 구조인데, 하드웨어를 직접 만들어 본 입장에서는 금방 한계가 보입니다. 소자 수만큼 RF 체인과 ADC를 붙이면 발열과 비용, 데이터 처리량이 눈에 띄게 튀어 오르기 때문입니다.

이번 프로젝트에서 제가 다루는 빔조향은 그런 “풀(Full) 디지털 배열”이 아닙니다. 그렇다고 예전 레이더처럼 단일 송수신기에 큰 패러볼라를 붙여서 모터로 돌리는 기계식 방식도 아닙니다. 현실적인 제약(전력, 크기, 비용)을 고려할 때, 지금 시점에서 가장 타당한 선택은 **아날로그 소자를 디지털로 제어하는 형태의 하이브리드 빔조향**입니다.

이 글은 그런 시스템에서 *“우리가 실제로 무엇을 제어하고 있는지”*를 한 번 정리해 보자는 취지입니다.

## 1. 시스템 구조

프로젝트의 신호 경로를 아주 단순하게 그려 보면 이렇습니다.

- **입력부:** 배열 안테나 10채널 중 8채널만 사용하며, RF 케이블을 타고 고주파 모듈로 진입합니다.
- **분배부:** 고주파 모듈 내에서 각 채널이 LNA를 지나 디바이더를 통해 빔조향 경로 #1과 #2로 분기됩니다.
- **제어부:** 각 경로에는 채널마다 **MFC1(채널 보정용)**과 **MFC2(각도 보정용)**가 자리하여 감쇠(ATT)와 지연(TTD)을 조절합니다.
- **출력부:** 마지막에는 경로별 8채널이 합쳐져 경로당 출력 1개, 총 2개의 RF 출력이 만들어집니다.

겉으로만 보면 전형적인 아날로그 빔포밍 구조입니다. 실제 빔 합성은 안테나에서 일어나고, RF 경로를 타는 신호는 끝까지 아날로그 영역에 머뭅니다.

그런데 빔이 어느 방향을 향하고, 빔 폭이 어떻게 나올지는 RF가 아니라 **디지털 제어**가 결정합니다. 외부에서 제어 모듈로 들어오는 정보는 딱 세 가지뿐입니다.

1. 운용 주파수 $f$
2. 목표 조향각 $\theta$
3. 빔조향 경로 선택 $p \in \{1,2\}$

이 세 숫자만 보고도, 제어 모듈은 “지금 이 순간 각 경로·각 채널의 ATT와 TTD를 어떻게 줄 것인지”를 결정해야 합니다.

## 2. 제어 메모리 구조

세 숫자를 입력으로 받은 제어 로직은 내부에서 세 가지 메모리(LUT)를 참조합니다.

- **채널 보정 테이블**: 조립 편차, 케이블 길이, 커넥터, 소자 편차, 온도 변화 등으로 생기는 **채널별 고정 오차(이득·지연)**를 줄이는 값입니다.
- **이론 TTD 테이블**: 배열 간격과 주파수, 조향각으로부터 수학적으로 계산한 **이상적인 시간 지연값**입니다.
- **각도 보정 테이블**: 소자 간 상호 결합(mutual coupling), 실제 안테나 배치 오차, 기구물 근접 영향 등으로 인해 앞의 두 데이터만으로는 맞지 않는 **조향각별 패턴의 비틀림**을 실측 데이터로 메워 주는 값입니다.

이 세 가지를 조합해, 경로 $p$와 채널 $i$에 대해 어떤 감쇠와 시간 지연을 줄지, 즉 $(ATT_{p,i}, TTD_{p,i})$를 결정해서 MFC로 내려보내는 것이 지금 우리가 설계해야 하는 “두뇌”입니다.

제어 모듈이 구현해야 하는 목표를 수식으로 쓰면 다음과 같습니다.

$$
(f,\theta,p) \Rightarrow \{(ATT_{p,i}, TTD_{p,i})\}_{i=1}^{8}
$$

표면적으로는 단순한 매핑 함수 하나처럼 보이지만, 안을 들여다보면 여러 층의 보정 철학이 숨어 있습니다. **채널 보정 테이블**은 VNA 같은 장비로 측정할 수 있는 고정 오차를 줄이는 역할을 합니다. **각도 보정 테이블**은 채널 보정과 이론 TTD만으로는 맞지 않는 패턴의 비틀림을, 패턴 챔버에서 얻은 실측 데이터를 기반으로 조정합니다. **빔조향(TTD) 테이블**은 배열 간격과 주파수, 조향각으로부터 나온 “이상적인 시간 지연” 값입니다.

이 세 레이어를 어떤 순서와 규칙으로 합칠지 정하는 것이 곧 빔조향 알고리즘의 핵심입니다.

## 3. PS와 TTD 비교

여기에 하나 더 얹어야 할 개념이 있습니다. 위상 배열 안테나에서 빔을 돌리는 방법은 크게 **위상천이(Phase Shift)**와 **시간지연(True Time Delay)** 두 가지입니다.

위상천이는 특정 주파수에서 위상을 맞추는 방식이라 협대역에서는 간단하고 저렴하지만, 대역폭이 넓어지면 주파수에 따라 조향각이 조금씩 틀어지는 **빔 스퀸트(beam squint)**가 생깁니다. “중심 주파수에서는 각도가 딱 맞는데, 대역 가장자리로 가면 살짝씩 틀어진다”는 경험을 하게 되는 이유입니다.

시간지연(TTD)은 파형 전체를 일정 시간만큼 밀어 내는 개념입니다. 도달 시간차를 직접 맞추기 때문에 주파수가 바뀌더라도 시간차는 그대로 유지되고, 결과적으로 광대역에서 조향각을 훨씬 안정적으로 유지할 수 있습니다.

우리가 경로×채널별로 8비트 TTD 값을 굳이 계산해 넣으려는 이유가 바로 여기에 있습니다. **“주파수 범위가 넓어도 빔의 방향과 폭을 디지털 쪽에서 끝까지 책임지겠다”**는 의지에 가깝습니다.

## 4. 정리

정리해 보면, 이 프로젝트에서 말하는 디지털 빔조향은 거창한 이론이라기보다는 다음 한 문장으로 요약할 수 있습니다.

**디지털 제어(메모리·LUT·알고리즘)가 아날로그 빔형성 소자(ATT/TTD/PS)를 움직여, 주파수·조향각·경로 입력에 따라 원하는 빔을 재현하도록 만드는 전체 시스템.**

다시 말해, **아날로그 근육 위에 얹힌 디지털 두뇌**가 바로 우리가 설계하려는 대상입니다.

남은 숙제는 이 두뇌의 규칙을 조금 더 구체적으로 적는 일입니다. 어느 단계에서 어떤 메모리를 먼저 신뢰할지, 채널 보정과 각도 보정을 어떤 순서와 해상도로 적용할지, EEPROM 8비트와 TTD+ATT 15비트라는 제한 속에서 LUT를 어떻게 설계할지, 그리고 최종적으로 챔버에서는 무엇부터 측정하고 어디서부터 디버깅을 시작할지.

이 글은 그중에서도 “우리가 실제로 제어하려는 것이 무엇인지”만 먼저 정리해 둔 것이고, 다음 글부터는 각 블록과 시험 순서를 하나씩 뜯어 보면서 “어디서부터 손을 대야 빔조향 품질이 눈에 띄게 좋아지는지”를 차근차근 정리해 보려고 합니다.


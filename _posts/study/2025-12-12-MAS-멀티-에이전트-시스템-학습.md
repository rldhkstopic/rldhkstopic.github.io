---
layout: post
title: "MAS(Multi-Agent System) 학습: PM 관점에서 AI 에이전트 활용하기"
date: 2025-12-12 11:00:00 +0900
author: rldhkstopic
category: study
subcategory: "모르는 개념"
tags: [AI, MAS, Multi-Agent System, PM, Cursor, Dify, CrewAI]
views: 0
---

## 학습 목표

아이디어를 구체화하는 과정에서 여러 역할별 AI 에이전트를 활용하고 싶었지만, 비용과 시스템 종속성 문제로 고민이 있었습니다. 이번 학습을 통해 MAS(Multi-Agent System)의 개념과 실제 적용 방법, 그리고 각 도구의 장단점을 명확히 이해하고자 했습니다.

## 핵심 개념: MAS(Multi-Agent System)란?

MAS는 여러 전문가 역할을 가진 AI 에이전트들이 협업하여 복잡한 작업을 수행하는 시스템입니다. 각 에이전트는 특정 역할(기획자, 디자이너, 개발자 등)을 맡아 작업을 수행하고, 오케스트레이터(Orchestrator)가 전체 프로세스를 관리합니다.

### 왜 MAS가 필요한가?

**1. 맥락 오염(Context Pollution) 방지**

한 채팅방에서 여러 역할을 동시에 수행하면 AI가 혼란스러워집니다. 기획자의 잔상이 개발 단계에 영향을 미쳐 최적화되지 않은 코드가 나올 수 있습니다.

**2. 전문성 강화**

한 명의 AI에게 모든 것을 시키면 맥락이 꼬이지만, 역할을 나누면 각자 좁은 영역에서 높은 정확도를 보입니다.

**3. 환각(Hallucination) 감소**

전문가 에이전트는 자신의 역할에만 집중하므로 더 정확한 결과를 제공합니다.

## 주요 MAS 프레임워크 비교

### 1. MetaGPT

**특징:**
- 한 줄의 명령어로 소프트웨어 회사를 운영
- Product Manager → Architect → Engineer → QA 순차적 협업
- 에이전트끼리 대화하며 결과물을 다듬음

**작동 방식:**
- 사용자: "스네이크 게임을 만들어줘"
- → Product Manager: PRD 작성
- → Architect: 기술 스택 선정
- → Engineer: 코드 작성
- → QA: 코드 리뷰 및 버그 수정

### 2. Microsoft AutoGen

**특징:**
- 대화형 에이전트에 특화
- 두 명의 에이전트가 목표 달성까지 대화하며 협업
- 코드 실행 및 오류 수정 자동화

**작동 방식:**
- 'User Proxy'와 'Assistant'가 끊임없이 대화하며 코드를 실행하고 오류를 고침
- "주식 차트 분석해줘" → 코드 작성 에이전트와 차트 검토 에이전트 협업

### 3. CrewAI

**특징:**
- 역할(Role), 목표(Goal), 배경(Backstory) 부여
- Manager Agent를 통한 업무 위임(Delegation)
- 최근 가장 인기 있는 도구

### 4. Google Vertex AI / Firebase Genkit

**특징:**
- 클라우드 플랫폼 기반
- Low-code로 에이전트 생성 및 관리
- Firebase Genkit은 앱 개발에 특화

**비교표:**

| 특징 | MS AutoGen | Google Vertex/Genkit |
|:--|:--|:--|
| 핵심 컨셉 | 대화(Conversation) | 작업 수행(Task Execution) |
| 구조 | 에이전트끼리 채팅하며 답 찾음 | 중앙 관리자가 도구 선택 및 실행 |
| 강점 | 복잡한 코딩, 시뮬레이션, 창의적 협업 | 실제 서비스 구현, 데이터 연동, 안정성 |
| 추천 용도 | 기획/개발 시뮬레이션 | 실제 작동하는 앱 서비스 |

## Cursor vs Dify vs CrewAI: 실전 비교

### Cursor의 장점

**1. 로컬 파일 시스템 통합**
- 프로젝트 전체 파일을 알고 있음 (RAG 기술)
- 수정이 필요한 부분만 똑똑하게 읽어서 AI에게 전달
- 에러 발생 시 즉시 인지 가능

**2. 비용 효율성**
- 구독료만 지불 (추가 API 비용 없음)
- 로컬 파일 시스템 사용으로 플랫폼 종속성 0%

**3. 개발 도구로서의 완성도**
- IDE 통합으로 코드 실행 및 디버깅 가능
- 실시간 피드백 및 수정

### Cursor의 한계

**1. 맥락 오염 문제**
- 한 채팅방에서 여러 역할을 수행하면 "잡종 에이전트"가 됨
- 해결책: 단계별로 채팅방을 나누고 파일로만 전달 (Clean Room 프로토콜)

**2. 피드백 루프 부재**
- 개발자가 코드를 짰는데 오류가 나면 사용자가 개입해야 함
- 자동화된 반복 검증이 어려움

**3. 에이전트 간 상호 소통 불가**
- 개발자가 기획서를 이해 못 해도 기획자에게 질문할 수 없음

### Dify의 장점

**1. 노코드 워크플로우**
- 화면상에서 블록을 연결하듯 에이전트 파이프라인 구성
- 시각적 구현 가능

**2. 자동화된 협업**
- 에이전트끼리 지지고 볶으며 완성도 향상
- 반복 검증 자동화

### Dify의 한계

**1. 로컬 파일 시스템 접근 불가**
- 웹 브라우저상의 도구일 뿐
- 에러 발생 시 복사-붙여넣기 지옥 반복

**2. 토큰 비용 증가**
- 프로젝트가 복잡해지면 관련 파일을 통째로 업로드해야 함
- 입력 토큰 비용이 기하급수적으로 증가

**3. 개발 도구로서의 한계**
- 텍스트 생성기일 뿐, 코드 실행기 아님
- 디버깅과 실행 환경 부재

### CrewAI의 특징

**장점:**
- 에이전트 간 양방향 대화 가능
- 자동화된 피드백 루프
- 확장성 (반복문으로 밤새 1,000번 수행 가능)

**단점:**
- Python 코드 작성 및 API 연동 필요
- API 비용 및 서버비 발생
- 구현 난이도 높음

## 실전 적용: Clean Room 프로토콜

Cursor에서 MAS를 구현하는 방법입니다. 핵심은 **"채팅방을 일회용 메모지처럼 쓰고 버리는 것"**입니다.

### 단계별 시뮬레이션

**Step 1. 기획 단계 (The Planner)**
- Action: Cmd + L (새 채팅)
- → "너는 기획자야. 아이디어를 구체화해서 `01_PRD.md` 파일에 저장해."
- Output: `01_PRD.md` 생성됨
- Critical Move: 이 채팅방을 삭제하거나 닫습니다.

**Step 2. 휴먼 게이트 (The Reviewer)**
- Action: 사용자가 `01_PRD.md` 파일을 읽고 직접 수정
- Reason: 직접 품질 통제(Quality Control)

**Step 3. 개발 단계 (The Developer)**
- Action: Cmd + L (완전 새로운 채팅)
- Input: "너는 시니어 개발자야. 첨부된 `01_PRD.md` 파일만 참고해서 코드를 짜."
- Why works: 새로운 채팅방의 LLM은 앞서 기획자와 나눈 잡담을 전혀 모릅니다.

### 왜 이 방식이 효과적인가?

**VHDL로 비유하면:**
- 기획 모듈(`Entity A`)의 출력 신호가 `PRD.md`
- 개발 모듈(`Entity B`)은 오직 `PRD.md`라는 입력 포트만 쳐다봄
- `Entity A` 내부에서 무슨 일이 있었는지는 `Entity B`가 알 필요도 없음
- 이것이 **모듈화(Modularization)**의 핵심

## PM 관점에서의 프로세스 설계

### 왜 순차적 분업이 필요한가?

**1. 오케스트레이터의 필요성**
- AI는 대화가 길어지면 앞의 내용을 잊음 (Context Window 제한)
- 오케스트레이터가 상태(State)를 제어하고 필요한 정보만 전달
- VHDL의 `Top Module`과 같은 역할

**2. 기획을 먼저 하는 이유**
- 목표가 모호하면 코드도 모호하게 나옴
- VHDL 설계에서 Block Diagram과 State Diagram을 먼저 그리는 것과 같음
- 제약 조건을 문서로 확정해야 나중에 딴소리를 안 함

**3. 디자인 단계의 필요성**
- 기획서만 주면 사용할 수 없는 화면이 나올 수 있음
- PCB Layout처럼 부품을 기판의 어디에 배치할지 결정
- "차트는 화면 상단 60%" 같은 구체적 지침 필요

**4. 개발을 마지막에 하는 이유**
- 코드 수정이 가장 비쌈 (비용 측면)
- 건축에서 설계도와 조감도가 확정되어야 벽돌을 쌓는 것과 같음
- 창의성을 발휘하게 두면 안 되는 단계

### 불확실성 감소 과정

이 프로세스는 **"AI의 불확실성(Entropy)을 단계별로 줄여나가는 과정"**입니다.

1. **아이디어 (불확실성 100%)**: 추상적인 생각
2. **기획 (불확실성 50%)**: 글로 정리하여 논리적 오류 제거
3. **디자인 (불확실성 20%)**: 시각화하여 사용성 오류 제거
4. **개발 (불확실성 0%)**: 확정된 내용을 기계어로 번역

## 비용 및 종속성 문제 해결

### 문제점

**1. 비용 문제**
- API 키 필요 → Billing 청구
- 수십 번 트라이 → 많은 비용 발생
- Cursor AI 구독만으로도 벅찬 상황

**2. 종속성 문제**
- 플랫폼에 의존해야 함
- 다른 시스템이나 플랫폼에 연결 시 복잡해짐
- 데이터가 플랫폼에 갇힘

### 해결 방안

**1. Cursor AI를 오케스트레이터로 활용**
- 별도의 API 키 불필요 (구독료에 포함)
- 로컬 파일 시스템 사용으로 플랫폼 종속성 0%
- 프로젝트 폴더에 `docs/` 폴더 생성 후 단계별 파일 생성

**2. 로컬 LLM (Ollama) 활용**
- 무료 모델 사용 (Llama 3, Gemma 2, DeepSeek Coder)
- API 호출 비용 0원
- 데이터가 외부 서버로 전송되지 않아 보안 완벽

**3. Markdown 중심의 파이프라인**
- 모든 산출물을 텍스트 파일(Markdown)로 저장
- 플랫폼의 DB나 메모리 기능 사용 안 함
- 표준 파일 형식으로 저장하여 어디서든 열 수 있음

## 최종 결론 및 추천

### PM으로서의 선택

**Cursor 하나로 끝내는 최적의 솔루션:**

1. **아이디어 구체화**: Cursor의 `Composer` (Cmd+I)를 켜고, "지금부터 코딩하지 말고 기획자로서 나와 대화하자. `idea.md` 파일에 내 생각을 정리해 줘"

2. **개발**: `idea.md`가 완성되면, 그때 "이 문서를 바탕으로 코딩해 줘"라고 태세 전환

**이것이 만족하는 조건:**
- 단일 플랫폼 (Cursor)
- 추가 비용 0원
- 시스템 꼬임 없음

### 언제 다른 도구를 써야 하나?

**Dify가 유리한 영역 (개발 제외):**
- 기획 자동화: "뉴스 앱 아이디어 내줘" → 시장 조사 → 경쟁사 분석 → 기능 명세서 작성
- 운영 자동화: 매일 아침 주식 뉴스를 긁어와서 요약하고 카톡으로 보내주는 봇
- CS 처리: 고객 문의가 오면 매뉴얼을 찾아서 답변 초안 작성

**CrewAI가 필요한 경우:**
- 에이전트끼리 지지고 볶으며 완성도를 높이는 진짜 시스템이 필요할 때
- 자동화된 피드백 루프가 필수적일 때
- 반복 검증이 많이 필요한 작업

## 참고 자료

- [MetaGPT GitHub](https://github.com/geekan/MetaGPT)
- [Microsoft AutoGen](https://github.com/microsoft/autogen)
- [CrewAI 공식 문서](https://docs.crewai.com/)
- [Google Vertex AI](https://cloud.google.com/vertex-ai)
- [Firebase Genkit](https://firebase.google.com/docs/genkit)

## 학습 후기

이번 학습을 통해 MAS의 개념과 실제 적용 방법을 명확히 이해할 수 있었습니다. 특히 Cursor를 활용한 Clean Room 프로토콜은 비용과 종속성 문제를 해결하면서도 효과적인 MAS를 구현할 수 있는 현실적인 방법이라는 것을 알게 되었습니다.

각 도구의 장단점을 명확히 파악했으니, 앞으로는 프로젝트의 특성에 맞는 도구를 선택할 수 있을 것 같습니다. 기획 단계에서는 Dify나 CrewAI를 활용하고, 실제 개발 단계에서는 Cursor를 활용하는 것이 최적의 전략일 것 같습니다.

